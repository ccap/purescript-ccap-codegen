module Ccap.Codegen.Scala
  ( outputSpec
  ) where

import Prelude
import Ccap.Codegen.Annotations as Annotations
import Ccap.Codegen.Ast as Ast
import Ccap.Codegen.Cst as Cst
import Ccap.Codegen.Parser.Export as Export
import Ccap.Codegen.Shared (OutputSpec, indented)
import Control.Monad.Reader (Reader, asks, runReader)
import Data.Array (foldl)
import Data.Array as Array
import Data.Array.NonEmpty (NonEmptyArray)
import Data.Array.NonEmpty as NonEmptyArray
import Data.Compactable (compact)
import Data.Foldable (class Foldable, any, intercalate)
import Data.List.NonEmpty as NonEmptyList
import Data.Maybe (Maybe(..), fromMaybe, maybe, maybe')
import Data.Monoid (guard)
import Data.String as String
import Data.Traversable (for, traverse)
import Data.TraversableWithIndex (forWithIndex)
import Data.Tuple (Tuple(..))
import Node.Path (FilePath)
import Text.PrettyPrint.Boxes (Box, (//), (<<>>))
import Text.PrettyPrint.Boxes as Boxes

type Env
  = { currentModule :: Ast.Module
    }

type Codegen
  = Reader Env

runCodegen :: forall a. Env -> Codegen a -> a
runCodegen = flip runReader

outputSpec :: OutputSpec
outputSpec =
  { render: Just <<< Boxes.render <<< oneModule
  , filePath: modulePath
  }

modulePath :: Ast.Module -> FilePath
modulePath (Ast.Module mod) = Export.toPath mod.exports.scalaPkg <> ".scala"

oneModule :: Ast.Module -> Box
oneModule mod@(Ast.Module { types }) = do
  let
    modDecl = primaryClass mod

    env =
      { currentModule: mod
      }

    body =
      runCodegen env do
        modDeclOutput <- traverse (typeDecl TopLevelCaseClass) modDecl
        declsOutput <- traverse (typeDecl CompanionObject) types
        pure
          $ Array.fromFoldable modDeclOutput
          <> [ curlyV
                ("object " <> objectName mod)
                (NonEmptyArray.toArray declsOutput)
            ]
  Boxes.vsep 1 Boxes.left do
    [ Boxes.text "// This file is automatically generated. Do not edit."
    , Boxes.text ("package " <> classPackage mod)
    , imports mod
    ]
      <> body

typeParams :: Array Cst.TypeParam -> Array String
typeParams params = (map (\(Cst.TypeParam p) -> initialUpper p) params)

objectName :: Ast.Module -> String
objectName (Ast.Module { exports: { scalaPkg } }) = fromMaybe scalaPkg $ Array.last $ Export.split scalaPkg

classPackage :: Ast.Module -> String
classPackage (Ast.Module { exports: { scalaPkg } }) = maybe scalaPkg Export.join $ Array.init $ Export.split scalaPkg

surroundH :: forall f. Foldable f => String -> String -> String -> f String -> String
surroundH pre delim post ss = pre <> intercalate delim ss <> post

parenH :: forall f. Foldable f => String -> String -> String -> f String -> String
parenH pre delim post = surroundH (pre <> "(") delim (")" <> post)

parenH_ :: forall f. Foldable f => f String -> String
parenH_ = parenH "" ", " ""

parentheses :: String -> String
parentheses s = "(" <> s <> ")"

quote :: String -> String
quote s = "\"" <> s <> "\""

surroundV ::
  forall f.
  Foldable f =>
  Functor f =>
  Box ->
  String ->
  Box ->
  f (String -> Box) ->
  Box
surroundV pre delim post boxes =
  pre
    // indented (Boxes.vcat Boxes.left (map (\boxF -> boxF delim) boxes))
    // post

curlyV :: forall f. Foldable f => Functor f => String -> f Box -> Box
curlyV pre boxes =
  surroundV
    (Boxes.text (pre <> " {"))
    ""
    (Boxes.char '}')
    (map const boxes)

parenV :: forall f. Foldable f => Functor f => String -> f Box -> Box
parenV pre boxes =
  surroundV
    (Boxes.text (pre <> "("))
    ","
    (Boxes.char ')')
    (map (\b d -> b <<>> Boxes.text d) boxes)

parenVBoxes ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  String ->
  String ->
  f (String -> Box) ->
  Box
parenVBoxes pre delim post =
  surroundV
    (Boxes.text (pre <> "("))
    delim
    (Boxes.text (")" <> post))

parenVBoxes_ ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  f (String -> Box) ->
  Box
parenVBoxes_ pre = parenVBoxes pre "," ""

parenVStrings ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  String ->
  String ->
  f String ->
  Box
parenVStrings pre delim post strings =
  parenVBoxes
    pre
    delim
    post
    (map (\s d -> Boxes.text (s <> d)) strings)

parenVStrings_ ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  f String ->
  Box
parenVStrings_ pre strings =
  parenVBoxes_
    pre
    (map (\s d -> Boxes.text (s <> d)) strings)

typeDescr :: String -> Array String -> String
typeDescr name typParams =
  if Array.null typParams then
    name
  else
    surroundH
      (name <> "[")
      ", "
      "]"
      typParams

standardImports :: Array String
standardImports =
  [ "cats.Monad"
  , "gov.wicourts.jsoncommon.Encoder"
  , "gov.wicourts.jsoncommon.Decoder"
  ]

imports :: Ast.Module -> Box
imports mod@(Ast.Module m) =
  let
    pkg = classPackage mod

    samePkg impt = classPackage impt == pkg

    impts = (\(Ast.Module r) -> r.exports.scalaPkg) <$> Array.filter (not <<< samePkg) m.imports

    extraImports =
      guard
        (hasOccId_ mod)
        [ "gov.wicourts.cc.tx.dbc.queries.HasOccId"
        ]

    all = extraImports <> impts <> standardImports # Array.sort >>> Array.nub
  in
    Boxes.vcat Boxes.left (all <#> \s -> Boxes.text ("import " <> s))

straddle :: String -> String -> String -> String
straddle between lhs rhs = lhs <> between <> rhs

arg :: String -> String -> String
arg = straddle ": "

assign :: String -> String -> String
assign = straddle " = "

type DeclSpec
  = { modifiers :: Array String
    , name :: String
    , typParams :: Array Cst.TypeParam
    , args :: Array { name :: String, typ :: String }
    , typ :: String
    }

defDecl' :: DeclSpec -> String -> Box
defDecl' spec post =
  let
    modifiers :: String
    modifiers =
      if Array.null spec.modifiers then
        ""
      else
        (intercalate " " spec.modifiers) <> " "

    pre :: String
    pre =
      modifiers
        <> "def "
        <> typeDescr spec.name (typeParams spec.typParams)

    post' :: String
    post' = ": " <> spec.typ <> post
  in
    if Array.null spec.args then
      Boxes.text (pre <> post')
    else
      parenVStrings
        pre
        ","
        post'
        (map (\arg' -> arg arg'.name arg'.typ) spec.args)

defDecl :: DeclSpec -> Box
defDecl declSpec = defDecl' declSpec ""

defDef :: DeclSpec -> Box -> Box
defDef declSpec defn =
  defDecl' declSpec " ="
    // indented defn

defDef1 :: DeclSpec -> String -> Box
defDef1 declSpec defn = defDecl' declSpec (" = " <> defn)

defType :: String -> Array Cst.TypeParam -> String
defType name typParams =
  "type "
    <> typeDescr name (typeParams typParams)
    <> " ="

defType1 :: String -> Array Cst.TypeParam -> String -> String
defType1 name typParams defn =
  defType name typParams
    <> " "
    <> defn

defVal' :: String -> String -> String
defVal' name typ =
  "val "
    <> name
    <> ": "
    <> typ
    <> " ="

defVal :: String -> String -> Box -> Box
defVal name typ defn =
  Boxes.text (defVal' name typ)
    // indented defn

defVal1 :: String -> String -> String -> String
defVal1 name typ defn =
  defVal' name typ
    <> " "
    <> defn

defValTag1 :: { valName :: String, tagType :: String, variableName :: String } -> String
defValTag1 { valName, tagType, variableName } =
  defVal1 valName tagType (tagType <> parentheses (quote variableName))

defEncoder :: Boolean -> String -> Array Cst.TypeParam -> Box -> Box
defEncoder includeName name pp =
  let
    typeParamParameters :: Array { name :: String, typ :: String }
    typeParamParameters =
      map
        ( \(Cst.TypeParam p) ->
            { name: "jsonEncoder_param_" <> initialUpper p
            , typ: typeDescr "Encoder" [ initialUpper p, "argonaut.Json" ]
            }
        )
        pp
  in
    defDef
      { modifiers: []
      , name: "jsonEncoder" <> if includeName then name else ""
      , typParams: pp
      , args: typeParamParameters
      , typ: typeDescr "Encoder" [ typeDescr name (typeParams pp), "argonaut.Json" ]
      }

defDecoder :: Boolean -> String -> Ast.ScalaDecoderType -> Box -> Box
defDecoder includeName name dType =
  defDef
    { modifiers: []
    , name: "jsonDecoder" <> if includeName then name else ""
    , typParams: [ Cst.TypeParam "M[_]: Monad" ]
    , args: []
    , typ: typeDescr ("Decoder." <> decoderType dType) [ "M", name ]
    }

wrapEncoder :: String -> Array Cst.TypeParam -> Ast.Typ -> String -> Codegen Box
wrapEncoder name pp t enc = do
  e <- encoder t
  pure
    ( defEncoder
        true
        name
        pp
        (parenVBoxes_ (e <> ".compose") [ const (Boxes.text enc) ])
    )

wrapDecoder ::
  Array Cst.Annotation ->
  String ->
  Ast.ScalaDecoderType ->
  Ast.Typ ->
  Box ->
  Codegen Box
wrapDecoder annots name dType t dec = do
  topDec <- decoder annots t
  pure
    ( defDecoder
        true
        name
        dType
        ( (parenVBoxes_ (topDec <> ".toEither.andThen") [ const dec ])
            // Boxes.text ".toValidated"
        )
    )

column :: TypeDeclOutputMode -> String -> Ast.RecordProp -> Codegen Box
column mode name prop = do
  ty <- case prop.typ of
    Ast.TType t -> typeDef mode t
    Ast.TParam (Cst.TypeParam c) -> pure (initialUpper c)
  let
    lambda = straddle " => "

    underlyingSqlType =
      map
        ( case _ of
            Ast.SqlTypePrimitive s -> s
            Ast.SqlTypeDbSupportType { dbSupportType } -> dbSupportType.underlyingSqlType
        )
        prop.sqlType
  pure
    ( defVal
        (initialUpper prop.name)
        (colType name)
        ( parenV
            (colType name)
            ( map
                (\{ lhs, rhs } -> Boxes.text (assign lhs rhs))
                [ { lhs: "eq"
                  , rhs:
                      lambda
                        (parenH_ [ "e1", "e2" ])
                        ("cats.kernel.Eq[" <> ty <> "].eqv(e1." <> prop.name <> ", e2." <> prop.name <> ")")
                  }
                , { lhs: "fragment"
                  , rhs:
                      lambda
                        "e"
                        ( """fr0"${e."""
                            <> prop.name
                            <> "} :: "
                            <> fromMaybe "unknown" underlyingSqlType
                            <> "\""
                        )
                  }
                , { lhs: "name"
                  , rhs: show prop.name
                  }
                , { lhs: "underlyingSqlType"
                  , rhs: maybe "(internal error)" show underlyingSqlType
                  }
                , { lhs: "isPrimaryKey"
                  , rhs: show (Annotations.getIsPrimaryKey prop.annots)
                  }
                , { lhs: "isDbManaged"
                  , rhs: show (Annotations.getIsDbManaged prop.annots)
                  }
                ]
            )
        )
    )

columns ::
  TypeDeclOutputMode ->
  String ->
  NonEmptyArray Ast.RecordProp ->
  Codegen Box
columns mode name props = do
  let
    extraImports = do
      prop <- NonEmptyArray.toArray props
      case prop.sqlType of
        Just (Ast.SqlTypeDbSupportType { needsImports: true, dbSupportType }) ->
          [ dbSupportType.instances.meta
          , dbSupportType.instances.equal
          ]
        _ -> []
  cols <- traverse (column mode name) props
  pure
    ( Boxes.text "object Columns {"
        // indented
            ( Boxes.text "import doobie.syntax.string.toSqlInterpolator"
                // Boxes.vcat Boxes.left (map (Boxes.text <<< append "import ") (Array.sort (Array.nub extraImports)))
                // Boxes.vcat Boxes.left cols
            )
        // Boxes.char '}'
    )

colType :: String -> String
colType name = dbMetadata <> ".Column[" <> name <> "]"

dbMetadata :: String
dbMetadata = "gov.wicourts.cc.tx.dbc.queries.DbMetadata"

defDbMetadata ::
  String ->
  NonEmptyArray Ast.RecordProp ->
  NonEmptyArray Ast.RecordProp ->
  Box
defDbMetadata name props primaryKeyProps =
  let
    typParams = [ name, "PrimaryKey" ]

    dbMetadataWithTypeParams = typeDescr dbMetadata typParams

    dbMetadataConstructorParams =
      [ "read" <> name
      , "read" <> name <> "PrimaryKey"
      , "write" <> name
      , "write" <> name <> "PrimaryKey"
      ]

    new =
      curlyV
        ( "new "
            <> dbMetadataWithTypeParams
            <> parenH_ dbMetadataConstructorParams
        )

    columnsRefs ::
      forall f.
      Foldable f =>
      Functor f =>
      String ->
      String ->
      String ->
      f Ast.RecordProp ->
      Box
    columnsRefs functionName typ constructor pp =
      defDef
        { modifiers: [ "override" ]
        , name: functionName
        , typParams: []
        , args: []
        , typ: typeDescr typ [ colType name ]
        }
        (parenVStrings_ constructor (map (\{ name: propName } -> "Columns." <> initialUpper propName) pp))

    allColumns =
      columnsRefs
        "columns"
        "cats.data.NonEmptyList"
        "cats.data.NonEmptyList.of"
        props

    primaryKey =
      defDef
        { modifiers: [ "override" ]
        , name: "primaryKey"
        , typParams: []
        , args: [ { name: "entity", typ: name } ]
        , typ: "PrimaryKey"
        }
        ( parenVStrings_
            "PrimaryKey"
            ( map
                (\{ name: propName } -> propName <> " = entity." <> propName)
                primaryKeyProps
            )
        )

    primaryKeyColumns =
      columnsRefs
        "primaryKeyColumns"
        "cats.data.NonEmptyList"
        "cats.data.NonEmptyList.of"
        primaryKeyProps

    tableName =
      defDef
        { modifiers: [ "override" ]
        , name: "tableName"
        , typParams: []
        , args: []
        , typ: "String"
        }
        (Boxes.text (show name))

    defn =
      new
        [ allColumns
        , primaryKey
        , primaryKeyColumns
        , tableName
        ]
  in
    defVal
      "dbMetadata"
      dbMetadataWithTypeParams
      defn

defInstances :: String -> String -> Array Cst.Annotation -> Box
defInstances name typ annots =
  maybe
    Boxes.nullBox
    ( \{ equal, meta } ->
        let
          meta' =
            fromMaybe
              (typeDescr "doobie.Meta" [ typ ])
              meta

          timap =
            ".timap("
              <> name
              <> ".apply)("
              <> name
              <> ".unwrap)"
        in
          curlyV
            ("object " <> name <> "T")
            [ Boxes.vcat
                Boxes.left
                [ defDef
                    { modifiers: [ "implicit" ]
                    , name: "equal" <> name
                    , typParams: []
                    , args: []
                    , typ: typeDescr "cats.Eq" [ name ]
                    }
                    ( Boxes.text
                        ( "cats.Eq.by((x: "
                            <> name
                            <> ") => "
                            <> name
                            <> ".unwrap(x))("
                            <> equal
                            <> ")"
                        )
                    )
                , defDef
                    { modifiers: [ "implicit" ]
                    , name: "meta" <> name
                    , typParams: []
                    , args: []
                    , typ: typeDescr "doobie.Meta" [ name ]
                    }
                    (Boxes.text (meta' <> timap))
                ]
            ]
    )
    (Annotations.getInstances annots)

defPrimaryKey :: TypeDeclOutputMode -> NonEmptyArray Ast.RecordProp -> Codegen Box
defPrimaryKey mode primaryKeyProps = do
  decls <- traverse (recordFieldType mode) primaryKeyProps
  pure
    ( parenVStrings_
        "final case class PrimaryKey"
        decls
    )

defDoobieInstances :: String -> Box
defDoobieInstances name =
  Boxes.text ("implicit val read" <> name <> ": doobie.util.Read[" <> name <> "] = implicitly")
    // Boxes.text ("implicit val write" <> name <> ": doobie.util.Write[" <> name <> "] = implicitly")
    // Boxes.text ("implicit val read" <> name <> "PrimaryKey: doobie.util.Read[PrimaryKey] = implicitly")
    // Boxes.text ("implicit val write" <> name <> "PrimaryKey: doobie.util.Write[PrimaryKey] = implicitly")

data TypeDeclOutputMode
  = TopLevelCaseClass
  | CompanionObject

derive instance eqTypeDeclOutputMode :: Eq TypeDeclOutputMode

noGenericParameters :: String
noGenericParameters = "// Scala decoders that involve parameterized types are not supported"

eqOccId :: Ast.RecordProp -> Boolean
eqOccId = eq "occId" <<< _.name

hasOccId :: NonEmptyArray Ast.RecordProp -> Boolean
hasOccId = any eqOccId

hasOccId_ :: Ast.Module -> Boolean
hasOccId_ mod =
  any
    ( \modDecl -> case Ast.typeDeclTopType modDecl of
        Ast.Record props -> hasOccId props
        Ast.Sum _ -> false
        Ast.Typ _ -> false
        Ast.Wrap _ -> false
    )
    (primaryClass mod)

typeDecl :: TypeDeclOutputMode -> Ast.TypeDecl -> Codegen Box
typeDecl outputMode typDecl@(Ast.TypeDecl { name, topType: tt, annots: an, params: pp, scalaDecoderType }) = case tt of
  Ast.Typ t -> do
    ty <- typeDef outputMode t
    e <- encoder t
    d <-
      maybe'
        (\_ -> pure (Boxes.text noGenericParameters))
        (\dType -> map (\d -> defDecoder true name dType (Boxes.text d)) (decoder an t))
        scalaDecoderType
    pure
      $ Boxes.text (defType1 name pp ty)
      // defEncoder true name pp (Boxes.text e)
      // d
  Ast.Wrap t -> do
    case Annotations.getWrapOpts "scala" an of
      Nothing -> do
        ty <- typeDef outputMode t
        e <- encoder t
        d <-
          maybe'
            (\_ -> pure (Boxes.text noGenericParameters))
            (\dType -> map (\d -> defDecoder true name dType (Boxes.text (d <> ".tagged"))) (decoder an t))
            scalaDecoderType
        let
          tagname = name <> "T"

          scalatyp = typeDescr "gov.wicourts.common.@@" [ ty, tagname ]
        pure
          $ Boxes.vcat
              Boxes.left
              [ Boxes.text ("final abstract class " <> tagname)
              , Boxes.text (defType1 name [] scalatyp)
              , Boxes.text
                  ( defVal1
                      name
                      (typeDescr "gov.wicourts.common.Tag.TagOf" [ tagname ])
                      (typeDescr "gov.wicourts.common.Tag.of" [ tagname ])
                  )
              , defEncoder true name pp (Boxes.text (e <> ".tagged"))
              , d
              , defInstances name ty an
              ]
      Just { typ, decode, encode } -> do
        wrappedEncoder <- wrapEncoder name pp t encode
        wrappedDecoder <-
          maybe'
            (\_ -> pure (Boxes.text noGenericParameters))
            ( \dType ->
                wrapDecoder
                  an
                  name
                  dType
                  t
                  (Boxes.text (decode <> ".toEither"))
            )
            scalaDecoderType
        pure
          $ Boxes.text (defType1 name [] typ)
          // wrappedEncoder
          // wrappedDecoder
  Ast.Record props -> do
    mod <- asks _.currentModule
    let
      addExtendsHasOccId =
        outputMode == TopLevelCaseClass
          && isPrimaryClass (objectName mod) typDecl
          && hasOccId props
    recordFieldTypes <-
      traverse
        (recordFieldType outputMode)
        props
    recordFields <- traverse recordFieldEncoder props
    let
      modName = objectName mod

      cls =
        parenVStrings
          ("final case class " <> typeDescr name (typeParams pp))
          ","
          (if addExtendsHasOccId then " extends HasOccId" else "")
          recordFieldTypes

      enc =
        defEncoder
          (modName /= name)
          name
          pp
          (parenVStrings_ "x => argonaut.Json.obj" recordFields)
    dec <-
      maybe'
        (\_ -> pure (Boxes.text noGenericParameters))
        ( \dType ->
            map
              (defDecoder (modName /= name) name dType)
              ( case NonEmptyArray.length props of
                  1 ->
                    map
                      Boxes.text
                      (singletonRecordDecoder name (NonEmptyArray.head props))
                  x
                    | x <= 12 -> smallRecordDecoder name props
                  _ -> largeRecordDecoder name props
              )
        )
        scalaDecoderType
    let
      companionObjectTarget =
        if modName == name then
          Nothing
        else
          Just name

      names = fieldNames (props <#> _.name)

      primaryKeyProps =
        NonEmptyArray.filter
          (\{ annots } -> Annotations.getIsPrimaryKey annots)
          props
    { fragments, meta, primaryKey, doobieInstances, columnDefs } <-
      maybe
        ( pure
            { meta: Boxes.nullBox
            , primaryKey: Boxes.nullBox
            , doobieInstances: Boxes.nullBox
            , columnDefs: Boxes.nullBox
            , fragments: Boxes.nullBox
            }
        )
        ( \primaryKeyProps' -> do
            columnDefs <- columns outputMode name props
            primaryKeyDef <- defPrimaryKey outputMode primaryKeyProps'
            fragments <- (doobieFragments name outputMode props)
            pure
              { meta: defDbMetadata name props primaryKeyProps'
              , primaryKey: primaryKeyDef
              , doobieInstances: defDoobieInstances name
              , columnDefs
              , fragments
              }
        )
        (NonEmptyArray.fromArray primaryKeyProps)
    let
      companionObjectBody =
        names
          // columnDefs
          // doobieInstances
          // meta
          // fragments

      companionObject =
        maybe
          companionObjectBody
          (\b -> curlyV ("object " <> b) [ companionObjectBody ])
          companionObjectTarget

      output
        | modName == name && outputMode == TopLevelCaseClass = cls

      output
        | modName == name && outputMode == CompanionObject =
          primaryKey
            // enc
            // dec
            // companionObject

      output
        | otherwise =
          cls
            // primaryKey
            // enc
            // dec
            // companionObject
    pure output
  Ast.Sum constructors ->
    maybe
      ( do
          let
            trait =
              if NonEmptyArray.length constructors > 1 then
                Boxes.text ("sealed trait " <> typeDescr name (typeParams pp))
              else
                Boxes.nullBox
          cs <-
            if NonEmptyArray.length constructors == 1 then
              dataConstructor outputMode name pp false (NonEmptyArray.head constructors)
            else do
              ccc <- traverse (dataConstructor outputMode name pp true) constructors
              pure (curlyV ("object " <> name) ccc)
          e <- sumTypeEncoder name pp constructors
          d <-
            maybe'
              (\_ -> pure (Boxes.text noGenericParameters))
              (\dType -> map (defDecoder true name dType) (sumTypeDecoder name constructors))
              scalaDecoderType
          pure
            ( trait
                // cs
                // defEncoder true name pp e
                // d
            )
      )
      ( \vs -> do
          let
            tagDecl modifiers =
              { modifiers
              , name: "tag"
              , typParams: []
              , args: []
              , typ: "String"
              }

            trait =
              curlyV
                ("sealed trait " <> name)
                [ defDecl (tagDecl []) ]

            variants =
              vs
                <#> \v ->
                    curlyV
                      ("case object " <> v <> " extends " <> name)
                      [ defDef1 (tagDecl [ "override" ]) (show v) ]

            assocs = vs <#> \v -> parenH_ [ show v, name <> "." <> v ]

            params = NonEmptyArray.cons (show name) assocs
          enc <- wrapEncoder name pp (Ast.Primitive Cst.PString) "_.tag"
          dec <-
            wrapDecoder
              an
              name
              Ast.Field
              (Ast.Primitive Cst.PString)
              ( parenVStrings_ (typeDescr "Decoder.enum" [ "M", name ]) params
                  // Boxes.text ".toEither"
              )
          pure
            ( trait
                // curlyV ("object " <> name) variants
                // enc
                // dec
            )
      )
      (Ast.noArgConstructorNames constructors)

sumTypeEncoder :: String -> Array Cst.TypeParam -> NonEmptyArray Ast.Constructor -> Codegen Box
sumTypeEncoder name pp constructors = do
  let
    withName :: String -> String
    withName s =
      if NonEmptyArray.length constructors == 1 then
        s
      else
        name <> "." <> s
  branches <-
    for constructors case _ of
      Ast.NoArg (Cst.ConstructorName n) ->
        pure
          ( Boxes.text
              ( if Array.null pp then
                  "case " <> withName n <> " =>"
                else
                  "case " <> withName n <> "() =>"
              )
              // indented
                  ( parenVStrings_
                      "Encoder.constructor"
                      [ show n, "Nil" ]
                  )
          )
      Ast.WithArgs (Cst.ConstructorName n) args -> do
        parts <-
          forWithIndex args \i c -> case c of
            Ast.TParam (Cst.TypeParam p) ->
              pure
                ( "jsonEncoder_param_"
                    <> initialUpper p
                    <> ".encode(param_"
                    <> show i
                    <> ")"
                )
            Ast.TType t -> do
              enc <- encoder t
              pure
                ( enc
                    <> ".encode(param_"
                    <> show i
                    <> ")"
                )
        pure
          ( parenVStrings
              ("case " <> withName n)
              ","
              " => "
              ( map
                  (\r -> "param_" <> show r)
                  (Array.range 0 (NonEmptyArray.length args - 1))
              )
              // indented
                  ( parenVBoxes_
                      "Encoder.constructor"
                      [ \d -> Boxes.text ((show n) <> d)
                      , \d -> parenVStrings "List" "," d parts
                      ]
                  )
          )
  pure (curlyV "_ match" branches)

sumTypeDecoder :: String -> NonEmptyArray Ast.Constructor -> Codegen Box
sumTypeDecoder name constructors = do
  let
    withName :: String -> String
    withName s =
      if NonEmptyArray.length constructors == 1 then
        s
      else
        name <> "." <> s
  branches <-
    for constructors case _ of
      Ast.NoArg (Cst.ConstructorName n) ->
        pure
          ( Boxes.text ("case (" <> show n <> ", Nil) =>")
              // indented
                  ( parenVStrings_
                      "Decoder.construct0"
                      [ withName n ]
                  )
          )
      Ast.WithArgs (Cst.ConstructorName n) args -> do
        parts <-
          forWithIndex args \i c -> case c of
            Ast.TParam (Cst.TypeParam _) -> pure "(not implemented)"
            Ast.TType t -> do
              dec <- decoder [] t
              pure (dec <> ".param(" <> show i <> ", param_" <> show i <> ")")
        let
          all =
            indented
              ( parenVStrings
                  ("Decoder.construct" <> show (NonEmptyArray.length args))
                  ","
                  ("(" <> withName n <> ".apply)")
                  (NonEmptyArray.cons (show n) parts)
              )
        pure
          ( Boxes.text
              ( "case ("
                  <> show n
                  <> ", "
                  <> parenH
                      "List"
                      ", "
                      ""
                      ( map
                          (\r -> "param_" <> show r)
                          (Array.range 0 (NonEmptyArray.length args - 1))
                      )
                  <> ") => "
              )
              // all
          )
  let
    -- XXX Awful, but there doesn't seem to be a better option besides a big boom
    failureBranch =
      Boxes.text "case (n, l) =>"
        // indented
            ( Boxes.text
                ( "sys.error(s\"Match error on type "
                    <> name
                    <> " for constructor $n with ${l.length} parameters\")"
                )
            )

    func =
      defVal
        "d"
        (typeDescr "Decoder.Form" [ "M", name ])
        (curlyV "p match" (branches `NonEmptyArray.snoc` failureBranch))
        // Boxes.text "d.toEither"
  pure
    ( Boxes.text "Decoder.constructor.toEither.flatMap { p =>"
        // indented func
        // Boxes.text "}.toValidated"
    )

dataConstructor ::
  TypeDeclOutputMode ->
  String ->
  Array Cst.TypeParam ->
  Boolean ->
  Ast.Constructor ->
  Codegen Box
dataConstructor outputMode name pp includeExtends = case _ of
  Ast.NoArg (Cst.ConstructorName n) ->
    pure
      ( Boxes.text
          ( if Array.null pp then
              "case object "
                <> n
                <> " extends "
                <> name
            else
              "final case class "
                <> typeDescr n (typeParams pp)
                <> "() extends "
                <> typeDescr name (typeParams pp)
          )
      )
  Ast.WithArgs (Cst.ConstructorName n) args -> do
    params <-
      forWithIndex args \i c -> do
        ty <- case c of
          Ast.TParam (Cst.TypeParam p) -> pure (initialUpper p)
          Ast.TType ttt -> typeDef outputMode ttt
        pure (arg ("param_" <> show i) ty)
    pure
      ( parenVStrings
          ("final case class " <> typeDescr n (typeParams pp))
          ","
          (if includeExtends then " extends " <> typeDescr name (typeParams pp) else "")
          params
      )

fieldNames :: NonEmptyArray String -> Box
fieldNames names =
  curlyV
    "object FieldNames"
    (names <#> (Boxes.text <<< fieldNameConst))
  where
  fieldNameConst s = defVal1 (initialUpper s) "String" (show s)

initialUpper :: String -> String
initialUpper s =
  let
    { before, after } = String.splitAt 1 s
  in
    String.toUpper before <> after

primitive :: Cst.Primitive -> String
primitive = case _ of
  Cst.PBoolean -> "Boolean"
  Cst.PInt -> "Int"
  Cst.PDecimal -> "BigDecimal"
  Cst.PString -> "String"
  Cst.PStringValidationHack -> "String"
  Cst.PJson -> "argonaut.Json"

generic :: String -> String -> String
generic typeName param = typeDescr typeName [ param ]

list :: String -> String
list = generic "List"

option :: String -> String
option = generic "Option"

typeDef :: TypeDeclOutputMode -> Ast.Typ -> Codegen String
typeDef mode = case _ of
  Ast.Ref tRef -> typeRef mode tRef
  Ast.Array (Ast.TType t) -> list <$> typeDef mode t
  Ast.Array (Ast.TParam (Cst.TypeParam p)) -> pure (list (initialUpper p))
  Ast.Option (Ast.TType t) -> option <$> typeDef mode t
  Ast.Option (Ast.TParam (Cst.TypeParam p)) -> pure (option (initialUpper p))
  Ast.Primitive p -> pure (primitive p)

typeRef :: TypeDeclOutputMode -> Ast.TRef -> Codegen String
typeRef mode { decl, typ: typeName, params } = do
  currentModule <- asks _.currentModule
  refParams <-
    for params case _ of
      Ast.TParam (Cst.TypeParam p) -> pure (initialUpper p)
      Ast.TType t -> typeDef mode t
  pure
    ( typeDescr
        ( maybe
            (internalTypeRef mode currentModule typeName)
            externalTypeRef
            decl
        )
        refParams
    )

internalTypeRef :: TypeDeclOutputMode -> Ast.Module -> String -> String
internalTypeRef mode currentModule = case mode of
  TopLevelCaseClass -> prefix [ objectName currentModule ]
  CompanionObject -> identity

externalTypeRef :: Tuple Ast.Module Ast.TypeDecl -> String
externalTypeRef (Tuple importedModule importedType) =
  let
    scalaName = objectName importedModule

    typeName = Ast.typeDeclName importedType
  in
    if needsQualifier scalaName importedType then
      prefix [ scalaName ] typeName
    else
      typeName

primaryClass :: Ast.Module -> Maybe Ast.TypeDecl
primaryClass (Ast.Module { types }) = NonEmptyList.find (\(Ast.TypeDecl { isPrimary }) -> isPrimary) types

isPrimaryClass :: String -> Ast.TypeDecl -> Boolean
isPrimaryClass modName typeD = modName == Ast.typeDeclName typeD && Ast.isRecord (Ast.typeDeclTopType typeD)

needsQualifier :: String -> Ast.TypeDecl -> Boolean
needsQualifier modName = not <<< isPrimaryClass modName

prefix :: Array String -> String -> String
prefix names = intercalate "." <<< Array.snoc names

encoder :: Ast.Typ -> Codegen String
encoder = case _ of
  Ast.Ref tRef@{ params } -> do
    refParams <-
      for params case _ of
        Ast.TParam (Cst.TypeParam p) -> pure ("jsonEncoder_param_" <> initialUpper p)
        Ast.TType t -> encoder t
    jsonTypeRef En refParams tRef
  Ast.Array (Ast.TType t) -> encoder t <#> jsonList
  Ast.Array (Ast.TParam (Cst.TypeParam e)) -> pure (jsonList ("jsonEncoder_param_" <> initialUpper e))
  Ast.Option (Ast.TType t) -> encoder t <#> jsonOption
  Ast.Option (Ast.TParam (Cst.TypeParam e)) -> pure (jsonOption ("jsonEncoder_param_" <> initialUpper e))
  Ast.Primitive p -> pure $ "Encoder" <> jsonPrimitive p

data Coder
  = De
  | En

decoder :: Array Cst.Annotation -> Ast.Typ -> Codegen String
decoder annots = case _ of
  Ast.Ref tRef -> jsonTypeRef De [] tRef
  Ast.Array (Ast.TType t) -> decoder annots t <#> jsonList
  Ast.Array (Ast.TParam (Cst.TypeParam e)) -> pure (jsonList ("jsonDecoder_param_" <> initialUpper e))
  Ast.Option (Ast.TType t) -> decoder annots t <#> jsonOption
  Ast.Option (Ast.TParam (Cst.TypeParam e)) -> pure (jsonOption ("jsonDecoder_param_" <> initialUpper e))
  Ast.Primitive p -> pure (("Decoder" <> jsonPrimitive p <> "[M]") <> decoderValidations annots)

jsonRef :: Coder -> String -> String
jsonRef coder typ =
  let
    which = case coder of
      De -> "Decoder"
      En -> "Encoder"

    typParam = case coder of
      De -> "[M]"
      En -> ""
  in
    "json" <> which <> typ <> typParam

jsonTypeRef :: Coder -> Array String -> Ast.TRef -> Codegen String
jsonTypeRef coder params { decl, typ, isPrimaryRef } =
  pure
    ( ( maybe
          (jsonRef coder (guard (not isPrimaryRef) typ))
          (\(Tuple m _) -> prefix [ objectName m ] (jsonRef coder (guard (not isPrimaryRef) typ)))
          decl
      )
        <> if Array.null params then "" else parenH "" ", " "" params
    )

jsonList :: String -> String
jsonList json = json <> ".list"

jsonOption :: String -> String
jsonOption json = json <> ".option"

jsonPrimitive :: Cst.Primitive -> String
jsonPrimitive = case _ of
  Cst.PBoolean -> ".boolean"
  Cst.PInt -> ".int"
  Cst.PDecimal -> ".decimal"
  Cst.PString -> ".string"
  Cst.PStringValidationHack -> ".stringValidationHack"
  Cst.PJson -> ".json"

decoderValidations :: Array Cst.Annotation -> String
decoderValidations annots = foldl (<>) "" validations
  where
  validations =
    compact
      [ maxLengthValidation <$> Annotations.getMaxLength annots
      , minLengthValidation <$> Annotations.getMinLength annots
      , maxSizeValidation <$> Annotations.getMaxSize annots
      , positiveValidation <$> Annotations.getIsPositive annots
      ]

maxLengthValidation :: String -> String
maxLengthValidation max = ".maxLength(" <> max <> ")"

minLengthValidation :: String -> String
minLengthValidation min = ".minLength(" <> min <> ")"

maxSizeValidation :: String -> String
maxSizeValidation max = ".maxSize(" <> max <> ")"

positiveValidation :: Unit -> String
positiveValidation _ = ".positive"

decoderType :: Ast.ScalaDecoderType -> String
decoderType = case _ of
  Ast.Field -> "Field"
  Ast.Form -> "Form"

encodeType :: Ast.Typ -> String -> Codegen String
encodeType t e =
  map
    (\e' -> e' <> ".encode" <> parenH_ [ e ])
    (encoder t)

encodeTypeParam :: Cst.TypeParam -> String -> String
encodeTypeParam (Cst.TypeParam t) e =
  "jsonEncoder_param_"
    <> initialUpper t
    <> ".encode("
    <> e
    <> ")"

recordFieldType :: TypeDeclOutputMode -> Ast.RecordProp -> Codegen String
recordFieldType mode { name, typ } = do
  ty <- case typ of
    Ast.TType t -> typeDef mode t
    Ast.TParam (Cst.TypeParam c) -> pure (initialUpper c)
  pure (arg name ty)

recordFieldEncoder :: Ast.RecordProp -> Codegen String
recordFieldEncoder { name, typ } = do
  ty <- case typ of
    Ast.TType t -> encodeType t ("x." <> name)
    Ast.TParam t -> pure (encodeTypeParam t ("x." <> name))
  pure (show name <> " -> " <> ty)

recordFieldDecoder :: Ast.RecordProp -> Codegen String
recordFieldDecoder { name, typ, annots } = case typ of
  Ast.TType t -> decoder annots t <#> (_ <> recordFieldProperty name)
  Ast.TParam _ -> pure "(not implemented)"

recordFieldProperty :: String -> String
recordFieldProperty name = ".property" <> parenH_ [ show name ]

singletonRecordDecoder :: String -> Ast.RecordProp -> Codegen String
singletonRecordDecoder name prop =
  recordFieldDecoder prop
    <#> (_ <> ".map(" <> name <> ".apply)")

smallRecordDecoder :: String -> NonEmptyArray Ast.RecordProp -> Codegen Box
smallRecordDecoder name props = do
  recordFieldDecoders <-
    traverse
      recordFieldDecoder
      props
  pure
    ( parenVStrings
        ("Decoder.formApplicative[M].map" <> show (NonEmptyArray.length props))
        ","
        ("(" <> name <> ".apply)")
        recordFieldDecoders
    )

-- | tree type for bulding cats Apply statements
data TupleApplyStatement
  = Final (Array Ast.RecordProp)
  | Intermediate (Array TupleApplyStatement)

largeRecordDecoder :: String -> NonEmptyArray Ast.RecordProp -> Codegen Box
largeRecordDecoder name nelProps = buildApplyStatement tupleStatements
  where
  -- XXX A compromise considering the late hour
  props = NonEmptyArray.toArray nelProps

  -- | collects all the props into a tree that can be parsed into cats.Apply statements
  tupleStatements :: Array TupleApplyStatement
  tupleStatements = go (Final <$> chunksOf 5 props)
    where
    go statements
      | Array.length statements > 12 = go (Intermediate <$> chunksOf 5 statements)

    go statements = statements

  -- | builds the Apply statements. The recursive funcion `go` returns a record with the two parts of
  -- | the syntax that need to be nested:
  -- | 1. the arguments to cats.Apply.tupleN (decoderDefinitionSyntax)
  -- | 2. the syntax to extract the values from the tuples (extractionSyntax)
  buildApplyStatement :: Array TupleApplyStatement -> Codegen Box
  buildApplyStatement statements =
    let
      recursionResults = go <$> statements
    in
      do
        decs <- traverse _.decoderDefinitionSyntax recursionResults
        pure
          ( parenVBoxes
              ("Decoder.formApplicative[M].map" <> show (Array.length statements))
              ","
              " {"
              decs
              // indented (applyAllParams (recursionResults <#> _.extractionSyntax))
              // Boxes.char '}'
          )
    where
    go (Final part) =
      if Array.length part == 1 then
        maybe
          ( { decoderDefinitionSyntax: pure (const Boxes.nullBox)
            , extractionSyntax: const Boxes.nullBox
            }
          )
          ( \r ->
              { decoderDefinitionSyntax:
                  map
                    (\s d -> Boxes.text (s <> d))
                    (recordFieldDecoder r)
              , extractionSyntax: const (Boxes.text r.name)
              }
          )
          (Array.head part)
      else
        { decoderDefinitionSyntax:
            do
              decs <- traverse recordFieldDecoder part
              pure \d ->
                parenVStrings
                  ("Decoder.formApplicative[M].tuple" <> show (Array.length part))
                  ","
                  d
                  decs
        , extractionSyntax: \d -> Boxes.text (parenH_ (map _.name part) <> d)
        }

    go (Intermediate parts) =
      let
        recursionResults = parts <#> go
      in
        { decoderDefinitionSyntax:
            do
              decs <- traverse _.decoderDefinitionSyntax recursionResults
              pure \d ->
                parenVBoxes
                  ("Decoder.formApplicative[M].tuple" <> show (Array.length parts))
                  ","
                  d
                  decs
        , extractionSyntax:
            \d ->
              parenVBoxes
                ""
                ","
                d
                (recursionResults <#> _.extractionSyntax)
        }

  applyAllParams :: Array (String -> Box) -> Box
  applyAllParams statements =
    parenVBoxes "case " "," " =>" statements
      // indented applyAllConstructor
    where
    applyAllConstructor =
      parenVStrings_
        name
        ( map
            (\{ lhs, rhs } -> assign lhs rhs)
            (map (\p -> { lhs: p.name, rhs: p.name }) props)
        )

chunksOf :: forall a. Int -> Array a -> Array (Array a)
chunksOf n as =
  Array.range 0 ((Array.length as - 1) / n)
    <#> \i -> Array.slice (i * n) (i * n + n) as

doobieFragments :: String -> TypeDeclOutputMode -> NonEmptyArray Ast.RecordProp -> Codegen Box
doobieFragments tableName mode props = do
  fragmentFieldTypes <-
    traverse fragmentType (Array.filter (not eqOccId) $ NonEmptyArray.toArray props)
  let
    instanceImports = do
      prop <- NonEmptyArray.toArray props
      case prop.sqlType of
        Just (Ast.SqlTypeDbSupportType { needsImports: true, dbSupportType }) ->
          Array.fromFoldable dbSupportType.instances.read
        _ -> []

    extraImports =
        Boxes.vcat Boxes.left
          $ [ Boxes.text "import gov.wicourts.jsoncommon.Selectable" ]
          <> map (\i -> Boxes.text $ "import " <> i) (Array.nub instanceImports)

    classDef :: String
    classDef =
      "final case class Fragments(tableIndex: Int) extends Selectable.Table"

    tableNameT :: Box
    tableNameT =
      Boxes.text
        $ defValTag1
            { tagType: "Selectable.TableNameT"
            , valName: "tableName"
            , variableName: tableName
            }

    selectableColumn :: Box
    selectableColumn =
      Boxes.text
        ( "def selectableColumn[A: doobie.util.Read](columnName: String): Selectable.SelectableColumn[A] =\
          \Selectable.SelectableColumn[A](tableName, tableIndex, columnName)"
        )

    defs :: Array Box
    defs = [ tableNameT, selectableColumn ] <> fragmentFieldTypes
  pure $ extraImports // curlyV classDef defs
  where
  fragmentType :: Ast.RecordProp -> Codegen Box
  fragmentType { name, typ } = do
    ty <- case typ of
      Ast.TType t -> typeDef mode t
      Ast.TParam (Cst.TypeParam c) -> pure (initialUpper c)
    let
      queryType = typeDescr "Selectable.SelectableColumn" [ ty ]

      implementation = "selectableColumn[" <> ty <> "](" <> quote name <> ")"
    pure $ Boxes.text $ defVal1 name queryType implementation
