module Ccap.Codegen.Scala
  ( outputSpec
  ) where

import Prelude
import Ccap.Codegen.Annotations as Annotations
import Ccap.Codegen.Ast as Ast
import Ccap.Codegen.Cst as Cst
import Ccap.Codegen.Parser.Export as Export
import Ccap.Codegen.Shared (OutputSpec, dbSupportTypes, indented)
import Control.Monad.Reader (Reader, asks, runReader)
import Data.Array (foldl)
import Data.Array as Array
import Data.Array.NonEmpty (NonEmptyArray)
import Data.Array.NonEmpty as NonEmptyArray
import Data.Compactable (compact)
import Data.Either (Either(..))
import Data.Foldable (class Foldable, any, intercalate)
import Data.List.NonEmpty as NonEmptyList
import Data.Maybe (Maybe(..), fromMaybe, maybe, maybe')
import Data.Monoid (guard)
import Data.String as String
import Data.Traversable (for, traverse)
import Data.TraversableWithIndex (forWithIndex)
import Data.Tuple (Tuple(..))
import Node.Path (FilePath)
import Text.PrettyPrint.Boxes (Box, (//))
import Text.PrettyPrint.Boxes as Boxes

type Env
  = { currentModule :: Ast.Module
    }

type Codegen
  = Reader Env

runCodegen :: forall a. Env -> Codegen a -> a
runCodegen = flip runReader

outputSpec :: OutputSpec
outputSpec =
  { render: Just <<< Boxes.render <<< oneModule
  , filePath: modulePath
  }

modulePath :: Ast.Module -> FilePath
modulePath (Ast.Module mod) = Export.toPath mod.exports.scalaPkg <> ".scala"

oneModule :: Ast.Module -> Box
oneModule mod@(Ast.Module { types }) = do
  let
    modDecl = primaryClass mod

    env =
      { currentModule: mod
      }

    body =
      runCodegen env do
        modDeclOutput <- traverse (typeDecl TopLevelCaseClass) modDecl
        declsOutput <- traverse (typeDecl CompanionObject) types
        pure
          $ Array.fromFoldable modDeclOutput
          <> [ curlyV
                ("object " <> objectName mod)
                (NonEmptyArray.toArray declsOutput)
            ]
  Boxes.vsep 1 Boxes.left do
    [ Boxes.text "// This file is automatically generated. Do not edit."
    , Boxes.text ("package " <> classPackage mod)
    , imports mod
    ]
      <> body

typeParams :: Array Cst.TypeParam -> Array String
typeParams params = (map (\(Cst.TypeParam p) -> initialUpper p) params)

objectName :: Ast.Module -> String
objectName (Ast.Module { exports: { scalaPkg } }) = fromMaybe scalaPkg $ Array.last $ Export.split scalaPkg

classPackage :: Ast.Module -> String
classPackage (Ast.Module { exports: { scalaPkg } }) = maybe scalaPkg Export.join $ Array.init $ Export.split scalaPkg

surroundH :: forall f. Foldable f => String -> String -> String -> f String -> String
surroundH pre delim post ss = pre <> intercalate delim ss <> post

parenH :: forall f. Foldable f => String -> String -> String -> f String -> String
parenH pre delim post = surroundH (pre <> "(") delim (")" <> post)

parenH_ :: forall f. Foldable f => f String -> String
parenH_ = parenH "" ", " ""

surroundV ::
  forall f.
  Foldable f =>
  Functor f =>
  Box ->
  String ->
  Box ->
  f (String -> Box) ->
  Box
surroundV pre delim post boxes =
  pre
    // indented (Boxes.vcat Boxes.left (map (\boxF -> boxF delim) boxes))
    // post

curlyV :: forall f. Foldable f => Functor f => String -> f Box -> Box
curlyV pre boxes =
  surroundV
    (Boxes.text (pre <> " {"))
    ""
    (Boxes.char '}')
    (map const boxes)

parenVBoxes ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  String ->
  String ->
  f (String -> Box) ->
  Box
parenVBoxes pre delim post =
  surroundV
    (Boxes.text (pre <> "("))
    delim
    (Boxes.text (")" <> post))

parenVBoxes_ ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  f (String -> Box) ->
  Box
parenVBoxes_ pre = parenVBoxes pre "," ""

parenVStrings ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  String ->
  String ->
  f String ->
  Box
parenVStrings pre delim post strings =
  parenVBoxes
    pre
    delim
    post
    (map (\s d -> Boxes.text (s <> d)) strings)

parenVStrings_ ::
  forall f.
  Foldable f =>
  Functor f =>
  String ->
  f String ->
  Box
parenVStrings_ pre strings =
  parenVBoxes_
    pre
    (map (\s d -> Boxes.text (s <> d)) strings)

typeDescr :: String -> Array String -> String
typeDescr name typParams =
  if Array.null typParams then
    name
  else
    surroundH
      (name <> "[")
      ", "
      "]"
      typParams

standardImports :: Array String
standardImports =
  [ "cats.Monad"
  , "gov.wicourts.jsoncommon.Encoder"
  , "gov.wicourts.jsoncommon.Decoder"
  ]

imports :: Ast.Module -> Box
imports mod@(Ast.Module m) =
  let
    pkg = classPackage mod

    samePkg impt = classPackage impt == pkg

    impts = (\(Ast.Module r) -> r.exports.scalaPkg) <$> Array.filter (not <<< samePkg) m.imports

    extraImports =
      guard
        (hasOccId_ mod)
        [ "gov.wicourts.cc.tx.dbc.queries.HasOccId"
        ]

    all = extraImports <> impts <> standardImports # Array.sort >>> Array.nub
  in
    Boxes.vcat Boxes.left (all <#> \s -> Boxes.text ("import " <> s))

straddle :: String -> String -> String -> String
straddle between lhs rhs = lhs <> between <> rhs

arg :: String -> String -> String
arg = straddle ": "

assign :: String -> String -> String
assign = straddle " = "

type DeclSpec
  = { modifiers :: Array String
    , name :: String
    , typParams :: Array Cst.TypeParam
    , args :: Array { name :: String, typ :: String }
    , typ :: String
    }

defDecl' :: DeclSpec -> String -> Box
defDecl' spec post =
  let
    modifiers :: String
    modifiers =
      if Array.null spec.modifiers then
        ""
      else
        (intercalate " " spec.modifiers) <> " "

    pre :: String
    pre =
      modifiers
        <> "def "
        <> typeDescr spec.name (typeParams spec.typParams)

    post' :: String
    post' = ": " <> spec.typ <> post
  in
    if Array.null spec.args then
      Boxes.text (pre <> post')
    else
      parenVStrings
        pre
        ","
        post'
        (map (\arg' -> arg arg'.name arg'.typ) spec.args)

defDecl :: DeclSpec -> Box
defDecl declSpec = defDecl' declSpec ""

defDef :: DeclSpec -> Box -> Box
defDef declSpec defn =
  defDecl' declSpec " ="
    // indented defn

defDef1 :: DeclSpec -> String -> Box
defDef1 declSpec defn = defDecl' declSpec (" = " <> defn)

defType' :: String -> Array Cst.TypeParam -> String
defType' name typParams =
  "type "
    <> typeDescr name (typeParams typParams)
    <> " ="

defType :: String -> Array Cst.TypeParam -> Box -> Box
defType name typParams defn =
  Boxes.text (defType' name typParams)
    // indented defn

defType1 :: String -> Array Cst.TypeParam -> String -> String
defType1 name typParams defn =
  defType' name typParams
    <> " "
    <> defn

defVal' :: String -> String -> String
defVal' name typ =
  "val "
    <> name
    <> ": "
    <> typ
    <> " ="

defVal :: String -> String -> Box -> Box
defVal name typ defn =
  Boxes.text (defVal' name typ)
    // indented defn

defVal1 :: String -> String -> String -> String
defVal1 name typ defn =
  defVal' name typ
    <> " "
    <> defn

defEncoder :: Boolean -> String -> Array Cst.TypeParam -> Box -> Box
defEncoder includeName name pp =
  let
    typeParamParameters :: Array { name :: String, typ :: String }
    typeParamParameters =
      map
        ( \(Cst.TypeParam p) ->
            { name: "jsonEncoder_param_" <> initialUpper p
            , typ: typeDescr "Encoder" [ initialUpper p, "argonaut.Json" ]
            }
        )
        pp
  in
    defDef
      { modifiers: []
      , name: "jsonEncoder" <> if includeName then name else ""
      , typParams: pp
      , args: typeParamParameters
      , typ: typeDescr "Encoder" [ typeDescr name (typeParams pp), "argonaut.Json" ]
      }

defDecoder :: Boolean -> String -> Ast.ScalaDecoderType -> Box -> Box
defDecoder includeName name dType =
  defDef
    { modifiers: []
    , name: "jsonDecoder" <> if includeName then name else ""
    , typParams: [ Cst.TypeParam "M[_]: Monad" ]
    , args: []
    , typ: typeDescr ("Decoder." <> decoderType dType) [ "M", name ]
    }

wrapEncoder :: String -> Array Cst.TypeParam -> Ast.Typ -> String -> Codegen Box
wrapEncoder name pp t enc = do
  e <- encoder t
  pure
    ( defEncoder
        true
        name
        pp
        (parenVBoxes_ (e <> ".compose") [ const (Boxes.text enc) ])
    )

wrapDecoder ::
  Array Cst.Annotation ->
  String ->
  Ast.ScalaDecoderType ->
  Ast.Typ ->
  Box ->
  Codegen Box
wrapDecoder annots name dType t dec = do
  topDec <- decoder annots t
  pure
    ( defDecoder
        true
        name
        dType
        ( (parenVBoxes_ (topDec <> ".toEither.andThen") [ const dec ])
            // Boxes.text ".toValidated"
        )
    )

dbMetadata :: String
dbMetadata = "gov.wicourts.cc.tx.dbc.queries.DbMetadata"

defDbMetadata ::
  String ->
  Array (Tuple Ast.RecordProp ColumnType) ->
  NonEmptyArray (Tuple Ast.RecordProp ColumnType) ->
  Box
defDbMetadata name nonPrimaryKeyProps primaryKeyProps =
  let
    typParams = [ name, "PrimaryKey" ]

    colType = dbMetadata <> ".Column[" <> name <> "]"

    dbMetadataWithTypeParams = typeDescr dbMetadata typParams

    dbMetadataPrereqs =
      typeDescr
        "gov.wicourts.cc.tx.dbc.queries.DbMetadataPrereqs"
        typParams

    new =
      curlyV
        ( "new "
            <> dbMetadataPrereqs
            <> " with "
            <> dbMetadataWithTypeParams
        )

    column (Tuple prop { underlyingType }) delim =
      let
        lambda = straddle " => "

        underlyingSqlType' = underlyingSqlType underlyingType
      in
        parenVStrings
          colType
          ","
          delim
          ( map
              (\{ lhs, rhs } -> assign lhs rhs)
              [ { lhs: "eq"
                , rhs:
                    lambda
                      (parenH_ [ "e1", "e2" ])
                      ( straddle
                          " === "
                          ("e1." <> prop.name)
                          ("e2." <> prop.name)
                      )
                }
              , { lhs: "fragment"
                , rhs:
                    lambda
                      "e"
                      ( """fr0"${e."""
                          <> prop.name
                          <> "} :: "
                          <> underlyingSqlType'
                          <> "\""
                      )
                }
              , { lhs: "name"
                , rhs: show prop.name
                }
              , { lhs: "underlyingSqlType"
                , rhs: show underlyingSqlType'
                }
              ]
          )

    columns ::
      forall f.
      Foldable f =>
      Functor f =>
      String ->
      String ->
      String ->
      f (Tuple Ast.RecordProp ColumnType) ->
      Box
    columns functionName typ constructor props =
      defDef
        { modifiers: [ "override" ]
        , name: functionName
        , typParams: []
        , args: []
        , typ: typeDescr typ [ colType ]
        }
        (parenVBoxes_ constructor (map column props))

    dbManagedColumns :: Box
    dbManagedColumns =
      let
        dbManagedProps =
          Array.filter
            (\(Tuple prop _) -> Annotations.getIsDbManaged prop.annots)
            (nonPrimaryKeyProps <> Array.fromFoldable primaryKeyProps)

        declSpec =
          { modifiers: [ "override" ]
          , name: "dbManagedColumns"
          , typParams: []
          , args: []
          , typ: typeDescr "Set" [ "String" ]
          }
      in
        if Array.null dbManagedProps then
          defDef1 declSpec "Set.empty"
        else
          defDef
            declSpec
            ( parenVBoxes_
                "Set"
                ( map
                    (\(Tuple prop _) delim -> Boxes.text ((show prop.name) <> delim))
                    dbManagedProps
                )
            )

    nonPrimaryKeyColumns =
      columns
        "nonPrimaryKeyColumns"
        "List"
        "List"
        nonPrimaryKeyProps

    primaryKey =
      defDef
        { modifiers: [ "override" ]
        , name: "primaryKey"
        , typParams: []
        , args: [ { name: "entity", typ: name } ]
        , typ: "PrimaryKey"
        }
        ( parenVStrings_
            ""
            ( map
                (\(Tuple { name: propName } _) -> "entity." <> propName)
                primaryKeyProps
            )
        )

    primaryKeyColumns =
      columns
        "primaryKeyColumns"
        "NonEmptyList"
        "NonEmptyList.of"
        primaryKeyProps

    tableName =
      defDef
        { modifiers: [ "override" ]
        , name: "tableName"
        , typParams: []
        , args: []
        , typ: "String"
        }
        (Boxes.text (show name))

    defn =
      new
        [ dbManagedColumns
        , nonPrimaryKeyColumns
        , primaryKey
        , primaryKeyColumns
        , tableName
        ]
  in
    defVal
      "dbMetadata"
      dbMetadataWithTypeParams
      defn

defInstances :: String -> String -> Array Cst.Annotation -> Box
defInstances name typ annots =
  maybe
    Boxes.nullBox
    ( \{ equal, meta } ->
        let
          meta' =
            fromMaybe
              (typeDescr "doobie.Meta" [ typ ])
              meta

          timap =
            ".timap("
              <> name
              <> ".apply)("
              <> name
              <> ".unwrap)"
        in
          curlyV
            ("object " <> name <> "T")
            [ Boxes.vcat
                Boxes.left
                [ defDef
                    { modifiers: [ "implicit" ]
                    , name: "equal" <> name
                    , typParams: []
                    , args: []
                    , typ: typeDescr "cats.Eq" [ name ]
                    }
                    ( Boxes.text
                        ( "cats.Eq.by((x: "
                            <> name
                            <> ") => "
                            <> name
                            <> ".unwrap(x))("
                            <> equal
                            <> ")"
                        )
                    )
                , defDef
                    { modifiers: [ "implicit" ]
                    , name: "meta" <> name
                    , typParams: []
                    , args: []
                    , typ: typeDescr "doobie.Meta" [ name ]
                    }
                    (Boxes.text (meta' <> timap))
                ]
            ]
    )
    (Annotations.getInstances annots)

type ColumnType
  = { isOption :: Boolean
    , typ :: String
    , underlyingType :: Either Cst.Primitive (Tuple Cst.ModuleName String)
    }

columnType :: Ast.RecordProp -> Maybe (Tuple Ast.RecordProp ColumnType)
columnType prop@{ typ } =
  let
    moduleName :: Tuple Ast.Module Ast.TypeDecl -> Tuple Cst.ModuleName String
    moduleName (Tuple mod typDecl) =
      let
        Ast.Module { name: modName } = mod

        typeName = Ast.typeDeclName typDecl
      in
        Tuple modName typeName

    moduleName_ :: Tuple Ast.Module Ast.TypeDecl -> String
    moduleName_ decl =
      let
        Tuple (Cst.ModuleName modName) typeName = moduleName decl
      in
        modName <> "." <> typeName

    option' :: String -> String
    option' t = "Option[" <> t <> "]"

    underlyingType ::
      Tuple Ast.Module Ast.TypeDecl ->
      Either Cst.Primitive (Tuple Cst.ModuleName String)
    underlyingType decl@(Tuple _ typDecl) =
      let
        Tuple mn@(Cst.ModuleName modName) typeName = moduleName decl
      in
        if modName == "Domains" then case Ast.typeDeclTopType typDecl of
          Ast.Wrap (Ast.Primitive p) -> Left p
          Ast.Wrap (Ast.Ref { decl: Just decl' }) ->
            let
              Tuple mn' typeName' = moduleName decl'
            in
              Right (Tuple mn' typeName')
          _ -> Right (Tuple mn typeName)
        else
          Right (Tuple mn typeName)
  in
    case typ of
      Ast.TParam _ -> Nothing
      Ast.TType (Ast.Array _) -> Nothing
      Ast.TType (Ast.Option (Ast.TType (Ast.Primitive p))) ->
        Just
          ( Tuple
              prop
              { isOption: true
              , typ: option' (primitive p)
              , underlyingType: Left p
              }
          )
      Ast.TType (Ast.Option (Ast.TType (Ast.Ref { decl: Just decl }))) ->
        Just
          ( Tuple
              prop
              { isOption: true
              , typ: option' (moduleName_ decl)
              , underlyingType: underlyingType decl
              }
          )
      Ast.TType (Ast.Option _) -> Nothing
      Ast.TType (Ast.Primitive p) ->
        Just
          ( Tuple
              prop
              { isOption: false
              , typ: primitive p
              , underlyingType: Left p
              }
          )
      Ast.TType (Ast.Ref { decl: Just decl }) ->
        Just
          ( Tuple
              prop
              { isOption: false
              , typ: moduleName_ decl
              , underlyingType: underlyingType decl
              }
          )
      Ast.TType (Ast.Ref { decl: Nothing }) -> Nothing

defPrimaryKey :: NonEmptyArray (Tuple Ast.RecordProp ColumnType) -> Box
defPrimaryKey primaryKeyProps =
  defType
    "PrimaryKey"
    []
    ( parenVStrings_
        ""
        ( map
            (\(Tuple _ { typ }) -> typ)
            primaryKeyProps
        )
    )

data TypeDeclOutputMode
  = TopLevelCaseClass
  | CompanionObject

derive instance eqTypeDeclOutputMode :: Eq TypeDeclOutputMode

noGenericParameters :: String
noGenericParameters = "// Scala decoders that involve parameterized types are not supported"

hasOccId :: NonEmptyArray Ast.RecordProp -> Boolean
hasOccId = any (eq "occId" <<< _.name)

hasOccId_ :: Ast.Module -> Boolean
hasOccId_ mod =
  any
    ( \modDecl -> case Ast.typeDeclTopType modDecl of
        Ast.Record props -> hasOccId props
        Ast.Sum _ -> false
        Ast.Typ _ -> false
        Ast.Wrap _ -> false
    )
    (primaryClass mod)

typeDecl :: TypeDeclOutputMode -> Ast.TypeDecl -> Codegen Box
typeDecl outputMode typDecl@(Ast.TypeDecl { name, topType: tt, annots: an, params: pp, scalaDecoderType }) = case tt of
  Ast.Typ t -> do
    ty <- typeDef outputMode t
    e <- encoder t
    d <-
      maybe'
        (\_ -> pure (Boxes.text noGenericParameters))
        (\dType -> map (\d -> defDecoder true name dType (Boxes.text d)) (decoder an t))
        scalaDecoderType
    pure
      $ Boxes.text (defType1 name pp ty)
      // defEncoder true name pp (Boxes.text e)
      // d
  Ast.Wrap t -> do
    case Annotations.getWrapOpts "scala" an of
      Nothing -> do
        ty <- typeDef outputMode t
        e <- encoder t
        d <-
          maybe'
            (\_ -> pure (Boxes.text noGenericParameters))
            (\dType -> map (\d -> defDecoder true name dType (Boxes.text (d <> ".tagged"))) (decoder an t))
            scalaDecoderType
        let
          tagname = name <> "T"

          scalatyp = typeDescr "gov.wicourts.common.@@" [ ty, tagname ]
        pure
          $ Boxes.vcat
              Boxes.left
              [ Boxes.text ("final abstract class " <> tagname)
              , Boxes.text (defType1 name [] scalatyp)
              , Boxes.text
                  ( defVal1
                      name
                      (typeDescr "gov.wicourts.common.Tag.TagOf" [ tagname ])
                      (typeDescr "gov.wicourts.common.Tag.of" [ tagname ])
                  )
              , defEncoder true name pp (Boxes.text (e <> ".tagged"))
              , d
              , defInstances name ty an
              ]
      Just { typ, decode, encode } -> do
        wrappedEncoder <- wrapEncoder name pp t encode
        wrappedDecoder <-
          maybe'
            (\_ -> pure (Boxes.text noGenericParameters))
            ( \dType ->
                wrapDecoder
                  an
                  name
                  dType
                  t
                  (Boxes.text (decode <> ".toEither"))
            )
            scalaDecoderType
        pure
          $ Boxes.text (defType1 name [] typ)
          // wrappedEncoder
          // wrappedDecoder
  Ast.Record props -> do
    mod <- asks _.currentModule
    let
      addExtendsHasOccId =
        outputMode == TopLevelCaseClass
          && isPrimaryClass (objectName mod) typDecl
          && hasOccId props
    recordFieldTypes <-
      traverse
        (recordFieldType outputMode)
        props
    recordFields <- traverse recordFieldEncoder props
    let
      modName = objectName mod

      cls =
        parenVStrings
          ("final case class " <> typeDescr name (typeParams pp))
          ","
          (if addExtendsHasOccId then " extends HasOccId" else "")
          recordFieldTypes

      enc =
        defEncoder
          (modName /= name)
          name
          pp
          (parenVStrings_ "x => argonaut.Json.obj" recordFields)
    dec <-
      maybe'
        (\_ -> pure (Boxes.text noGenericParameters))
        ( \dType ->
            map
              (defDecoder (modName /= name) name dType)
              ( case NonEmptyArray.length props of
                  1 ->
                    map
                      Boxes.text
                      (singletonRecordDecoder name (NonEmptyArray.head props))
                  x
                    | x <= 12 -> smallRecordDecoder name props
                  _ -> largeRecordDecoder name props
              )
        )
        scalaDecoderType
    let
      fieldNamesTarget =
        if modName == name then
          Nothing
        else
          Just name

      names = fieldNames fieldNamesTarget (props <#> _.name)

      propsWithColumnType = NonEmptyArray.mapMaybe columnType props

      { no: nonPrimaryKeyProps, yes: primaryKeyProps } =
        Array.partition
          (\(Tuple { annots } _) -> Annotations.getIsPrimaryKey annots)
          propsWithColumnType

      { extraImports, meta, primaryKey } =
        maybe
          { extraImports: Boxes.nullBox
          , meta: Boxes.nullBox
          , primaryKey: Boxes.nullBox
          }
          ( \primaryKeyProps' ->
              let
                allProps = nonPrimaryKeyProps <> primaryKeyProps

                moduleName { typ } =
                  let
                    fromRef ref =
                      map
                        (\(Tuple (Ast.Module { name }) _) -> name)
                        ref.decl
                  in
                    case typ of
                      Ast.TParam _ -> Nothing
                      Ast.TType (Ast.Option (Ast.TType (Ast.Ref ref))) -> fromRef ref
                      Ast.TType (Ast.Ref ref) -> fromRef ref
                      Ast.TType _ -> Nothing

                usesDomains =
                  any
                    ( \(Tuple prop _) ->
                        any
                          (\(Cst.ModuleName modName) -> modName == "Domains")
                          (moduleName prop)
                    )
                    allProps

                requiresCommonMetaImport =
                  let
                    isCommonDbSupportType underlyingType =
                      any
                        ( \(Tuple (Cst.ModuleName modName) typeName) ->
                            any
                              ( \dbSupportType ->
                                  dbSupportType.isCommon
                                    && (dbSupportType.moduleName == modName)
                                    && (dbSupportType.typeName == typeName)
                              )
                              dbSupportTypes
                        )
                        underlyingType

                    isDomains prop =
                      any
                        (\(Cst.ModuleName n) -> n == "Domains")
                        (moduleName prop)
                  in
                    any
                      ( \(Tuple prop { underlyingType }) ->
                          not isDomains prop
                            && isCommonDbSupportType underlyingType
                      )
                      allProps
              in
                { extraImports:
                    Boxes.vcat
                      Boxes.left
                      ( Array.concat
                          [ guard usesDomains [ Boxes.text "import Domains._" ]
                          , [ Boxes.text "import cats.data.NonEmptyList"
                            , Boxes.text "import cats.implicits._"
                            , Boxes.text "import doobie.implicits._"
                            ]
                          , guard
                              requiresCommonMetaImport
                              [ Boxes.text "import gov.wicourts.common.Meta._" ]
                          ]
                      )
                , meta: defDbMetadata name nonPrimaryKeyProps primaryKeyProps'
                , primaryKey: defPrimaryKey primaryKeyProps'
                }
          )
          (NonEmptyArray.fromArray primaryKeyProps)

      output
        | modName == name && outputMode == TopLevelCaseClass = cls

      output
        | modName == name && outputMode == CompanionObject =
          extraImports
            // primaryKey
            // enc
            // dec
            // names
            // meta

      output
        | otherwise =
          cls
            // extraImports
            // primaryKey
            // enc
            // dec
            // names
            // meta
    pure output
  Ast.Sum constructors ->
    maybe
      ( do
          let
            trait =
              if NonEmptyArray.length constructors > 1 then
                Boxes.text ("sealed trait " <> typeDescr name (typeParams pp))
              else
                Boxes.nullBox
          cs <-
            if NonEmptyArray.length constructors == 1 then
              dataConstructor outputMode name pp false (NonEmptyArray.head constructors)
            else do
              ccc <- traverse (dataConstructor outputMode name pp true) constructors
              pure (curlyV ("object " <> name) ccc)
          e <- sumTypeEncoder name pp constructors
          d <-
            maybe'
              (\_ -> pure (Boxes.text noGenericParameters))
              (\dType -> map (defDecoder true name dType) (sumTypeDecoder name constructors))
              scalaDecoderType
          pure
            ( trait
                // cs
                // defEncoder true name pp e
                // d
            )
      )
      ( \vs -> do
          let
            tagDecl modifiers =
              { modifiers
              , name: "tag"
              , typParams: []
              , args: []
              , typ: "String"
              }

            trait =
              curlyV
                ("sealed trait " <> name)
                [ defDecl (tagDecl []) ]

            variants =
              vs
                <#> \v ->
                    curlyV
                      ("case object " <> v <> " extends " <> name)
                      [ defDef1 (tagDecl [ "override" ]) (show v) ]

            assocs = vs <#> \v -> parenH_ [ show v, name <> "." <> v ]

            params = NonEmptyArray.cons (show name) assocs
          enc <- wrapEncoder name pp (Ast.Primitive Cst.PString) "_.tag"
          dec <-
            wrapDecoder
              an
              name
              Ast.Field
              (Ast.Primitive Cst.PString)
              ( parenVStrings_ (typeDescr "Decoder.enum" [ "M", name ]) params
                  // Boxes.text ".toEither"
              )
          pure
            ( trait
                // curlyV ("object " <> name) variants
                // enc
                // dec
            )
      )
      (Ast.noArgConstructorNames constructors)

sumTypeEncoder :: String -> Array Cst.TypeParam -> NonEmptyArray Ast.Constructor -> Codegen Box
sumTypeEncoder name pp constructors = do
  let
    withName :: String -> String
    withName s =
      if NonEmptyArray.length constructors == 1 then
        s
      else
        name <> "." <> s
  branches <-
    for constructors case _ of
      Ast.NoArg (Cst.ConstructorName n) ->
        pure
          ( Boxes.text
              ( if Array.null pp then
                  "case " <> withName n <> " =>"
                else
                  "case " <> withName n <> "() =>"
              )
              // indented
                  ( parenVStrings_
                      "Encoder.constructor"
                      [ show n, "Nil" ]
                  )
          )
      Ast.WithArgs (Cst.ConstructorName n) args -> do
        parts <-
          forWithIndex args \i c -> case c of
            Ast.TParam (Cst.TypeParam p) ->
              pure
                ( "jsonEncoder_param_"
                    <> initialUpper p
                    <> ".encode(param_"
                    <> show i
                    <> ")"
                )
            Ast.TType t -> do
              enc <- encoder t
              pure
                ( enc
                    <> ".encode(param_"
                    <> show i
                    <> ")"
                )
        pure
          ( parenVStrings
              ("case " <> withName n)
              ","
              " => "
              ( map
                  (\r -> "param_" <> show r)
                  (Array.range 0 (NonEmptyArray.length args - 1))
              )
              // indented
                  ( parenVBoxes_
                      "Encoder.constructor"
                      [ \d -> Boxes.text ((show n) <> d)
                      , \d -> parenVStrings "List" "," d parts
                      ]
                  )
          )
  pure (curlyV "_ match" branches)

sumTypeDecoder :: String -> NonEmptyArray Ast.Constructor -> Codegen Box
sumTypeDecoder name constructors = do
  let
    withName :: String -> String
    withName s =
      if NonEmptyArray.length constructors == 1 then
        s
      else
        name <> "." <> s
  branches <-
    for constructors case _ of
      Ast.NoArg (Cst.ConstructorName n) ->
        pure
          ( Boxes.text ("case (" <> show n <> ", Nil) =>")
              // indented
                  ( parenVStrings_
                      "Decoder.construct0"
                      [ withName n ]
                  )
          )
      Ast.WithArgs (Cst.ConstructorName n) args -> do
        parts <-
          forWithIndex args \i c -> case c of
            Ast.TParam (Cst.TypeParam _) -> pure "(not implemented)"
            Ast.TType t -> do
              dec <- decoder [] t
              pure (dec <> ".param(" <> show i <> ", param_" <> show i <> ")")
        let
          all =
            indented
              ( parenVStrings
                  ("Decoder.construct" <> show (NonEmptyArray.length args))
                  ","
                  ("(" <> withName n <> ".apply)")
                  (NonEmptyArray.cons (show n) parts)
              )
        pure
          ( Boxes.text
              ( "case ("
                  <> show n
                  <> ", "
                  <> parenH
                      "List"
                      ", "
                      ""
                      ( map
                          (\r -> "param_" <> show r)
                          (Array.range 0 (NonEmptyArray.length args - 1))
                      )
                  <> ") => "
              )
              // all
          )
  let
    -- XXX Awful, but there doesn't seem to be a better option besides a big boom
    failureBranch =
      Boxes.text "case (n, l) =>"
        // indented
            ( Boxes.text
                ( "sys.error(s\"Match error on type "
                    <> name
                    <> " for constructor $n with ${l.length} parameters\")"
                )
            )

    func =
      defVal
        "d"
        (typeDescr "Decoder.Form" [ "M", name ])
        (curlyV "p match" (branches `NonEmptyArray.snoc` failureBranch))
        // Boxes.text "d.toEither"
  pure
    ( Boxes.text "Decoder.constructor.toEither.flatMap { p =>"
        // indented func
        // Boxes.text "}.toValidated"
    )

dataConstructor ::
  TypeDeclOutputMode ->
  String ->
  Array Cst.TypeParam ->
  Boolean ->
  Ast.Constructor ->
  Codegen Box
dataConstructor outputMode name pp includeExtends = case _ of
  Ast.NoArg (Cst.ConstructorName n) ->
    pure
      ( Boxes.text
          ( if Array.null pp then
              "case object "
                <> n
                <> " extends "
                <> name
            else
              "final case class "
                <> typeDescr n (typeParams pp)
                <> "() extends "
                <> typeDescr name (typeParams pp)
          )
      )
  Ast.WithArgs (Cst.ConstructorName n) args -> do
    params <-
      forWithIndex args \i c -> do
        ty <- case c of
          Ast.TParam (Cst.TypeParam p) -> pure (initialUpper p)
          Ast.TType ttt -> typeDef outputMode ttt
        pure (arg ("param_" <> show i) ty)
    pure
      ( parenVStrings
          ("final case class " <> typeDescr n (typeParams pp))
          ","
          (if includeExtends then " extends " <> typeDescr name (typeParams pp) else "")
          params
      )

fieldNames :: Maybe String -> NonEmptyArray String -> Box
fieldNames mod names =
  maybe
    body
    (\m -> curlyV ("object " <> m) [ body ])
    mod
  where
  body =
    curlyV
      "object FieldNames"
      (names <#> (Boxes.text <<< fieldNameConst))

  fieldNameConst s = defVal1 (initialUpper s) "String" (show s)

initialUpper :: String -> String
initialUpper s =
  let
    { before, after } = String.splitAt 1 s
  in
    String.toUpper before <> after

primitive :: Cst.Primitive -> String
primitive = case _ of
  Cst.PBoolean -> "Boolean"
  Cst.PInt -> "Int"
  Cst.PDecimal -> "BigDecimal"
  Cst.PString -> "String"
  Cst.PStringValidationHack -> "String"
  Cst.PJson -> "argonaut.Json"

generic :: String -> String -> String
generic typeName param = typeDescr typeName [ param ]

list :: String -> String
list = generic "List"

option :: String -> String
option = generic "Option"

typeDef :: TypeDeclOutputMode -> Ast.Typ -> Codegen String
typeDef mode = case _ of
  Ast.Ref tRef -> typeRef mode tRef
  Ast.Array (Ast.TType t) -> list <$> typeDef mode t
  Ast.Array (Ast.TParam (Cst.TypeParam p)) -> pure (list (initialUpper p))
  Ast.Option (Ast.TType t) -> option <$> typeDef mode t
  Ast.Option (Ast.TParam (Cst.TypeParam p)) -> pure (option (initialUpper p))
  Ast.Primitive p -> pure (primitive p)

typeRef :: TypeDeclOutputMode -> Ast.TRef -> Codegen String
typeRef mode { decl, typ: typeName, params } = do
  currentModule <- asks _.currentModule
  refParams <-
    for params case _ of
      Ast.TParam (Cst.TypeParam p) -> pure (initialUpper p)
      Ast.TType t -> typeDef mode t
  pure
    ( typeDescr
        ( maybe
            (internalTypeRef mode currentModule typeName)
            externalTypeRef
            decl
        )
        refParams
    )

internalTypeRef :: TypeDeclOutputMode -> Ast.Module -> String -> String
internalTypeRef mode currentModule = case mode of
  TopLevelCaseClass -> prefix [ objectName currentModule ]
  CompanionObject -> identity

externalTypeRef :: Tuple Ast.Module Ast.TypeDecl -> String
externalTypeRef (Tuple importedModule importedType) =
  let
    scalaName = objectName importedModule

    typeName = Ast.typeDeclName importedType
  in
    if needsQualifier scalaName importedType then
      prefix [ scalaName ] typeName
    else
      typeName

underlyingSqlType ::
  Either Cst.Primitive (Tuple Cst.ModuleName String) ->
  String
underlyingSqlType = case _ of
  Left Cst.PBoolean -> "boolean"
  Left Cst.PDecimal -> "numeric"
  Left Cst.PInt -> "integer"
  Left Cst.PString -> "text"
  Right (Tuple (Cst.ModuleName modName) typeName) ->
    maybe
      "text"
      _.underlyingSqlType
      ( Array.find
          ( \dbSupportType ->
              dbSupportType.moduleName == modName
                && (dbSupportType.typeName == typeName)
          )
          dbSupportTypes
      )
  _ -> "text"

primaryClass :: Ast.Module -> Maybe Ast.TypeDecl
primaryClass (Ast.Module { types }) = NonEmptyList.find (\(Ast.TypeDecl { isPrimary }) -> isPrimary) types

isPrimaryClass :: String -> Ast.TypeDecl -> Boolean
isPrimaryClass modName typeD = modName == Ast.typeDeclName typeD && Ast.isRecord (Ast.typeDeclTopType typeD)

needsQualifier :: String -> Ast.TypeDecl -> Boolean
needsQualifier modName = not <<< isPrimaryClass modName

prefix :: Array String -> String -> String
prefix names = intercalate "." <<< Array.snoc names

encoder :: Ast.Typ -> Codegen String
encoder = case _ of
  Ast.Ref tRef@{ params } -> do
    refParams <-
      for params case _ of
        Ast.TParam (Cst.TypeParam p) -> pure ("jsonEncoder_param_" <> initialUpper p)
        Ast.TType t -> encoder t
    jsonTypeRef En refParams tRef
  Ast.Array (Ast.TType t) -> encoder t <#> jsonList
  Ast.Array (Ast.TParam (Cst.TypeParam e)) -> pure (jsonList ("jsonEncoder_param_" <> initialUpper e))
  Ast.Option (Ast.TType t) -> encoder t <#> jsonOption
  Ast.Option (Ast.TParam (Cst.TypeParam e)) -> pure (jsonOption ("jsonEncoder_param_" <> initialUpper e))
  Ast.Primitive p -> pure $ "Encoder" <> jsonPrimitive p

data Coder
  = De
  | En

decoder :: Array Cst.Annotation -> Ast.Typ -> Codegen String
decoder annots = case _ of
  Ast.Ref tRef -> jsonTypeRef De [] tRef
  Ast.Array (Ast.TType t) -> decoder annots t <#> jsonList
  Ast.Array (Ast.TParam (Cst.TypeParam e)) -> pure (jsonList ("jsonDecoder_param_" <> initialUpper e))
  Ast.Option (Ast.TType t) -> decoder annots t <#> jsonOption
  Ast.Option (Ast.TParam (Cst.TypeParam e)) -> pure (jsonOption ("jsonDecoder_param_" <> initialUpper e))
  Ast.Primitive p -> pure (("Decoder" <> jsonPrimitive p <> "[M]") <> decoderValidations annots)

jsonRef :: Coder -> String -> String
jsonRef coder typ =
  let
    which = case coder of
      De -> "Decoder"
      En -> "Encoder"

    typParam = case coder of
      De -> "[M]"
      En -> ""
  in
    "json" <> which <> typ <> typParam

jsonTypeRef :: Coder -> Array String -> Ast.TRef -> Codegen String
jsonTypeRef coder params { decl, typ, isPrimaryRef } =
  pure
    ( ( maybe
          (jsonRef coder (guard (not isPrimaryRef) typ))
          (\(Tuple m _) -> prefix [ objectName m ] (jsonRef coder (guard (not isPrimaryRef) typ)))
          decl
      )
        <> if Array.null params then "" else parenH "" ", " "" params
    )

jsonList :: String -> String
jsonList json = json <> ".list"

jsonOption :: String -> String
jsonOption json = json <> ".option"

jsonPrimitive :: Cst.Primitive -> String
jsonPrimitive = case _ of
  Cst.PBoolean -> ".boolean"
  Cst.PInt -> ".int"
  Cst.PDecimal -> ".decimal"
  Cst.PString -> ".string"
  Cst.PStringValidationHack -> ".stringValidationHack"
  Cst.PJson -> ".json"

decoderValidations :: Array Cst.Annotation -> String
decoderValidations annots = foldl (<>) "" validations
  where
  validations =
    compact
      [ maxLengthValidation <$> Annotations.getMaxLength annots
      , minLengthValidation <$> Annotations.getMinLength annots
      , maxSizeValidation <$> Annotations.getMaxSize annots
      , positiveValidation <$> Annotations.getIsPositive annots
      ]

maxLengthValidation :: String -> String
maxLengthValidation max = ".maxLength(" <> max <> ")"

minLengthValidation :: String -> String
minLengthValidation min = ".minLength(" <> min <> ")"

maxSizeValidation :: String -> String
maxSizeValidation max = ".maxSize(" <> max <> ")"

positiveValidation :: Unit -> String
positiveValidation _ = ".positive"

decoderType :: Ast.ScalaDecoderType -> String
decoderType = case _ of
  Ast.Field -> "Field"
  Ast.Form -> "Form"

encodeType :: Ast.Typ -> String -> Codegen String
encodeType t e =
  map
    (\e' -> e' <> ".encode" <> parenH_ [ e ])
    (encoder t)

encodeTypeParam :: Cst.TypeParam -> String -> String
encodeTypeParam (Cst.TypeParam t) e =
  "jsonEncoder_param_"
    <> initialUpper t
    <> ".encode("
    <> e
    <> ")"

recordFieldType :: TypeDeclOutputMode -> Ast.RecordProp -> Codegen String
recordFieldType mode { name, typ } = do
  ty <- case typ of
    Ast.TType t -> typeDef mode t
    Ast.TParam (Cst.TypeParam c) -> pure (initialUpper c)
  pure (arg name ty)

recordFieldEncoder :: Ast.RecordProp -> Codegen String
recordFieldEncoder { name, typ } = do
  ty <- case typ of
    Ast.TType t -> encodeType t ("x." <> name)
    Ast.TParam t -> pure (encodeTypeParam t ("x." <> name))
  pure (show name <> " -> " <> ty)

recordFieldDecoder :: Ast.RecordProp -> Codegen String
recordFieldDecoder { name, typ, annots } = case typ of
  Ast.TType t -> decoder annots t <#> (_ <> recordFieldProperty name)
  Ast.TParam _ -> pure "(not implemented)"

recordFieldProperty :: String -> String
recordFieldProperty name = ".property" <> parenH_ [ show name ]

singletonRecordDecoder :: String -> Ast.RecordProp -> Codegen String
singletonRecordDecoder name prop =
  recordFieldDecoder prop
    <#> (_ <> ".map(" <> name <> ".apply)")

smallRecordDecoder :: String -> NonEmptyArray Ast.RecordProp -> Codegen Box
smallRecordDecoder name props = do
  recordFieldDecoders <-
    traverse
      recordFieldDecoder
      props
  pure
    ( parenVStrings
        ("Decoder.formApplicative[M].map" <> show (NonEmptyArray.length props))
        ","
        ("(" <> name <> ".apply)")
        recordFieldDecoders
    )

-- | tree type for bulding cats Apply statements
data TupleApplyStatement
  = Final (Array Ast.RecordProp)
  | Intermediate (Array TupleApplyStatement)

largeRecordDecoder :: String -> NonEmptyArray Ast.RecordProp -> Codegen Box
largeRecordDecoder name nelProps = buildApplyStatement tupleStatements
  where
  -- XXX A compromise considering the late hour
  props = NonEmptyArray.toArray nelProps

  -- | collects all the props into a tree that can be parsed into cats.Apply statements
  tupleStatements :: Array TupleApplyStatement
  tupleStatements = go (Final <$> chunksOf 5 props)
    where
    go statements
      | Array.length statements > 12 = go (Intermediate <$> chunksOf 5 statements)

    go statements = statements

  -- | builds the Apply statements. The recursive funcion `go` returns a record with the two parts of
  -- | the syntax that need to be nested:
  -- | 1. the arguments to cats.Apply.tupleN (decoderDefinitionSyntax)
  -- | 2. the syntax to extract the values from the tuples (extractionSyntax)
  buildApplyStatement :: Array TupleApplyStatement -> Codegen Box
  buildApplyStatement statements =
    let
      recursionResults = go <$> statements
    in
      do
        decs <- traverse _.decoderDefinitionSyntax recursionResults
        pure
          ( parenVBoxes
              ("Decoder.formApplicative[M].map" <> show (Array.length statements))
              ","
              " {"
              decs
              // indented (applyAllParams (recursionResults <#> _.extractionSyntax))
              // Boxes.char '}'
          )
    where
    go (Final part) =
      if Array.length part == 1 then
        maybe
          ( { decoderDefinitionSyntax: pure (const Boxes.nullBox)
            , extractionSyntax: const Boxes.nullBox
            }
          )
          ( \r ->
              { decoderDefinitionSyntax:
                  map
                    (\s d -> Boxes.text (s <> d))
                    (recordFieldDecoder r)
              , extractionSyntax: const (Boxes.text r.name)
              }
          )
          (Array.head part)
      else
        { decoderDefinitionSyntax:
            do
              decs <- traverse recordFieldDecoder part
              pure \d ->
                parenVStrings
                  ("Decoder.formApplicative[M].tuple" <> show (Array.length part))
                  ","
                  d
                  decs
        , extractionSyntax: \d -> Boxes.text (parenH_ (map _.name part) <> d)
        }

    go (Intermediate parts) =
      let
        recursionResults = parts <#> go
      in
        { decoderDefinitionSyntax:
            do
              decs <- traverse _.decoderDefinitionSyntax recursionResults
              pure \d ->
                parenVBoxes
                  ("Decoder.formApplicative[M].tuple" <> show (Array.length parts))
                  ","
                  d
                  decs
        , extractionSyntax:
            \d ->
              parenVBoxes
                ""
                ","
                d
                (recursionResults <#> _.extractionSyntax)
        }

  applyAllParams :: Array (String -> Box) -> Box
  applyAllParams statements =
    parenVBoxes "case " "," " =>" statements
      // indented applyAllConstructor
    where
    applyAllConstructor =
      parenVStrings_
        name
        ( map
            (\{ lhs, rhs } -> assign lhs rhs)
            (map (\p -> { lhs: p.name, rhs: p.name }) props)
        )

chunksOf :: forall a. Int -> Array a -> Array (Array a)
chunksOf n as =
  Array.range 0 ((Array.length as - 1) / n)
    <#> \i -> Array.slice (i * n) (i * n + n) as
