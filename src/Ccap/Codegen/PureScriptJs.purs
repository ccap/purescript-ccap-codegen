module Ccap.Codegen.PureScriptJs
  ( outputSpec
  ) where

import Prelude
import Ccap.Codegen.Ast as Ast
import Ccap.Codegen.Cst as Cst
import Ccap.Codegen.Parser.Export as Export
import Ccap.Codegen.Shared (DelimitedLiteralDir(..), FastPathDecoderType(..), OutputSpec, delimitedLiteral, fastPathDecoderType, indented)
import Data.Array as Array
import Data.Array.NonEmpty (NonEmptyArray)
import Data.Array.NonEmpty as NonEmptyArray
import Data.Maybe (Maybe(..))
import Data.Tuple (Tuple(..))
import Node.Path (FilePath)
import Text.PrettyPrint.Boxes (Box, render, text, vsep, (//))
import Text.PrettyPrint.Boxes as Boxes

outputSpec :: OutputSpec
outputSpec =
  { render: map render <<< oneModule
  , filePath: modulePath
  }

modulePath :: Ast.Module -> FilePath
modulePath (Ast.Module mod) = Export.toPath mod.exports.pursPkg <> ".js"

records :: Ast.Module -> Array (Tuple String (NonEmptyArray Ast.RecordProp))
records (Ast.Module mod) =
  Array.mapMaybe
    ( case _ of
        Ast.TypeDecl { name, topType: Ast.Record props } -> Just (Tuple name props)
        _ -> Nothing
    )
    (Array.fromFoldable mod.types)

oneModule :: Ast.Module -> Maybe Box
oneModule m@(Ast.Module _) = do
  let
    recs = records m
  if Array.null recs then
    Nothing
  else
    Just
      ( text "// This file is automatically generated. Do not edit."
          // vsep 1 Boxes.left (map (\(Tuple name props) -> oneRecord name props) recs)
      )

oneRecord :: String -> NonEmptyArray Ast.RecordProp -> Box
oneRecord name props =
  text ("export const decode_" <> name <> " = function (api) {")
    // indented
        ( text "return function(json) {"
            // indented
                ( text "if (! (typeof json === 'object' && !Array.isArray(json) && json !== null)) {"
                    // indented (text "return api.typeMismatch('This value must be an object');")
                    // text "}"
                    // text ""
                    // vsep 1 Boxes.left (map decodeProp props)
                    // returnAll props
                )
            // text "};"
        )
    // text "};"

returnAll :: NonEmptyArray Ast.RecordProp -> Box
returnAll props =
  text "return api.right("
    // indented (delimitedLiteral Vert '{' '}' (NonEmptyArray.toArray (map (\{ name } -> text (name <> ": " <> name)) props)))
    // text ");"

decodeProp :: Ast.RecordProp -> Box
decodeProp { name, typ } =
  text ("let " <> name <> ";")
    // text ("if (! ('" <> name <> "' in json)) {")
    // indented (text ("return api.missingValue(" <> show ("Property '" <> name <> "'") <> ");"))
    // text "}"
    // case typ of
        Ast.TParam (Cst.TypeParam _) ->
          decodeCustom
            { name
            , decoder: "api.jsonCodec_" <> name
            }
        Ast.TType t -> case fastPathDecoderType t of
          Just FBoolean ->
            decodeFastStandard
              { name
              , negTest: "typeof json." <> name <> " !== 'boolean'"
              , descr: "boolean"
              }
          Just FString ->
            decodeFastStandard
              { name
              , negTest: "typeof json." <> name <> " !== 'string'"
              , descr: "string"
              }
          Just FInt -> do
            let
              ref = "json." <> name
            decodeFastStandard
              { name
              , negTest: "typeof " <> ref <> " !== 'number' && (" <> ref <> " | 0) === " <> ref
              , descr: "integer"
              }
          Just FOptionBoolean ->
            decodeFastOptionStandard
              { name
              , negTest: "typeof json." <> name <> " !== 'boolean'"
              , descr: "boolean"
              }
          Just FOptionString ->
            decodeFastOptionStandard
              { name
              , negTest: "typeof json." <> name <> " !== 'string'"
              , descr: "string"
              }
          Just FOptionInt -> do
            let
              ref = "json." <> name
            decodeFastOptionStandard
              { name
              , negTest: "typeof " <> ref <> " !== 'number' && (" <> ref <> " | 0) === " <> ref
              , descr: "integer"
              }
          Just FJson -> text (name <> " = json." <> name <> ";")
          Just FOptionJson ->
            text ("if (json." <> name <> " === null) {")
              // indented (text (name <> " = api.nothing;"))
              // text "} else {"
              // indented (text (name <> " = api.just(json." <> name <> ");"))
              // text "}"
          Just FDecimal ->
            decodeCustom
              { name
              , decoder: "api.jsonCodec_primitive_decimal"
              }
          Just FOptionDecimal ->
            decodeOptionCustom
              { name
              , decoder: "api.jsonCodec_primitive_decimal"
              }
          Nothing ->
            decodeCustom
              { name
              , decoder: "api.jsonCodec_" <> name
              }

decodeFastStandard :: { name :: String, negTest :: String, descr :: String } -> Box
decodeFastStandard { name, negTest, descr } =
  text ("if (" <> negTest <> ") {")
    // indented (text ("return api.typeMismatch(" <> (show ("Property '" <> name <> "' must be a(n) " <> descr)) <> ");"))
    // text "}"
    // text (name <> " = json." <> name <> ";")

decodeFastOptionStandard :: { name :: String, negTest :: String, descr :: String } -> Box
decodeFastOptionStandard { name, negTest, descr } =
  text ("if (json." <> name <> " === null) {")
    // indented (text (name <> " = api.nothing;"))
    // text "} else {"
    // indented
        ( text ("if (" <> negTest <> ") {")
            // indented (text ("return api.typeMismatch(" <> (show ("Property '" <> name <> "' must be a(n) " <> descr)) <> ");"))
            // text "}"
            // text (name <> " = api.just(json." <> name <> ");")
        )
    // text "}"

decodeCustom :: { name :: String, decoder :: String } -> Box
decodeCustom { name, decoder } =
  text (name <> " = " <> decoder <> ".decode(json." <> name <> ");")
    // text ("if (api.isLeft(" <> name <> ")) {")
    // indented (text ("return api.addErrorPrefix(" <> show ("Property '" <> name <> "': ") <> ")(" <> name <> ");"))
    // text "}"
    // text (name <> " = api.fromRight()(" <> name <> ");")

decodeOptionCustom :: { name :: String, decoder :: String } -> Box
decodeOptionCustom { name, decoder } =
  text ("if (json." <> name <> " === null) {")
    // indented (text (name <> " = api.nothing;"))
    // text "} else {"
    // indented
        ( text (name <> " = " <> decoder <> ".decode(json." <> name <> ");")
            // text ("if (api.isLeft(" <> name <> ")) {")
            // indented (text ("return " <> name <> ";"))
            // text "}"
            // text (name <> " = api.just(api.fromRight()(" <> name <> "));")
        )
    // text "}"
