-- This file is automatically generated. Do not edit.

module Test.Ccap.Codegen.FastDecoding.FastTest where

import Ccap.Codegen.Runtime as R
import Data.Argonaut.Core as A
import Data.Argonaut.Decode (class DecodeJson)
import Data.Argonaut.Decode.Error (JsonDecodeError(..))
import Data.Argonaut.Encode (class EncodeJson)
import Data.Array as Array
import Data.Bifunctor as B
import Data.Decimal (Decimal)
import Data.Either as E
import Data.Generic.Rep (class Generic)
import Data.Maybe (Maybe)
import Data.Maybe as M
import Data.Newtype (class Newtype)
import Data.Show.Generic (genericShow)
import Data.Tuple as T
import Foreign.Object as FO
import Prelude
import Test.Ccap.Codegen.FastDecoding.Domains as Domains

type Basic = WithParams (Ref Decimal) Int (Array Boolean)
jsonCodec_Basic :: R.JsonCodec Basic
jsonCodec_Basic =
  jsonCodec_WithParams (jsonCodec_Ref R.jsonCodec_decimal) R.jsonCodec_int (R.jsonCodec_array R.jsonCodec_boolean)

type WithParams a b c =
  { stringTest :: String
  , intTest :: Int
  , booleanTest :: Boolean
  , decimalTest :: Decimal
  , stringOpt :: Maybe String
  , intOpt :: Maybe Int
  , booleanOpt :: Maybe Boolean
  , decimalOpt :: Maybe Decimal
  , stringT :: Domains.StringT
  , intT :: Domains.IntT
  , booleanT :: Domains.BooleanT
  , decimalT :: Domains.DecimalT
  , stringOptT :: Maybe Domains.StringT
  , intOptT :: Maybe Domains.IntT
  , booleanOptT :: Maybe Domains.BooleanT
  , decimalOptT :: Maybe Domains.DecimalT
  , ref :: Ref c
  , refOpt :: Maybe (Ref a)
  , anotherRef :: Ref Int
  , yetAnotherRef :: Maybe (Ref String)
  , arrayOfB :: Array b
  , aC :: c
  , xx :: MyList String
  , yy :: MyTuple String Int
  }
type DecoderApi_WithParams a b c =
  { nothing :: forall a. M.Maybe a
  , just :: forall a. a -> M.Maybe a
  , isLeft :: forall a b. E.Either a b -> Boolean
  , fromRight :: forall a b. Partial => E.Either a b -> b
  , right :: forall a b. b -> E.Either a b
  , left :: forall a b. a -> E.Either a b
  , addErrorPrefix :: forall a. String -> E.Either JsonDecodeError a -> E.Either JsonDecodeError a
  , jsonCodec_primitive_decimal :: R.JsonCodec Decimal
  , jsonCodec_ref :: R.JsonCodec (Ref c)
  , jsonCodec_refOpt :: R.JsonCodec (Maybe (Ref a))
  , jsonCodec_anotherRef :: R.JsonCodec (Ref Int)
  , jsonCodec_yetAnotherRef :: R.JsonCodec (Maybe (Ref String))
  , jsonCodec_arrayOfB :: R.JsonCodec (Array b)
  , jsonCodec_aC :: R.JsonCodec c
  , jsonCodec_xx :: R.JsonCodec (MyList String)
  , jsonCodec_yy :: R.JsonCodec (MyTuple String Int)
  }
decoderApi_WithParams :: forall a b c. R.JsonCodec a -> R.JsonCodec b -> R.JsonCodec c -> DecoderApi_WithParams a b c
decoderApi_WithParams jsonCodec_param_a jsonCodec_param_b jsonCodec_param_c =
  { nothing: M.Nothing
  , just: M.Just
  , isLeft: E.isLeft
  , fromRight: \(E.Right v) -> v
  , right: E.Right
  , left: E.Left
  , addErrorPrefix: \_ -> B.lmap identity
  , jsonCodec_primitive_decimal: R.jsonCodec_decimal
  , jsonCodec_ref: jsonCodec_Ref jsonCodec_param_c
  , jsonCodec_refOpt: R.jsonCodec_maybe (jsonCodec_Ref jsonCodec_param_a)
  , jsonCodec_anotherRef: jsonCodec_Ref R.jsonCodec_int
  , jsonCodec_yetAnotherRef: R.jsonCodec_maybe (jsonCodec_Ref R.jsonCodec_string)
  , jsonCodec_arrayOfB: R.jsonCodec_array jsonCodec_param_b
  , jsonCodec_aC: jsonCodec_param_c
  , jsonCodec_xx: jsonCodec_MyList R.jsonCodec_string
  , jsonCodec_yy: jsonCodec_MyTuple R.jsonCodec_string R.jsonCodec_int
  }
foreign import decode_WithParams :: forall a b c. DecoderApi_WithParams a b c -> A.Json -> E.Either JsonDecodeError (WithParams a b c)
jsonCodec_WithParams :: forall a b c. R.JsonCodec a -> R.JsonCodec b -> R.JsonCodec c -> R.JsonCodec (WithParams a b c)
jsonCodec_WithParams jsonCodec_param_a jsonCodec_param_b jsonCodec_param_c =
  { decode: decode_WithParams (decoderApi_WithParams jsonCodec_param_a jsonCodec_param_b jsonCodec_param_c)
  , encode: \p -> A.fromObject $
      FO.fromFoldable
        [ T.Tuple "stringTest" (R.jsonCodec_string.encode p.stringTest)
        , T.Tuple "intTest" (R.jsonCodec_int.encode p.intTest)
        , T.Tuple "booleanTest" (R.jsonCodec_boolean.encode p.booleanTest)
        , T.Tuple "decimalTest" (R.jsonCodec_decimal.encode p.decimalTest)
        , T.Tuple "stringOpt" ((R.jsonCodec_maybe R.jsonCodec_string).encode p.stringOpt)
        , T.Tuple "intOpt" ((R.jsonCodec_maybe R.jsonCodec_int).encode p.intOpt)
        , T.Tuple "booleanOpt" ((R.jsonCodec_maybe R.jsonCodec_boolean).encode p.booleanOpt)
        , T.Tuple "decimalOpt" ((R.jsonCodec_maybe R.jsonCodec_decimal).encode p.decimalOpt)
        , T.Tuple "stringT" (Domains.jsonCodec_StringT.encode p.stringT)
        , T.Tuple "intT" (Domains.jsonCodec_IntT.encode p.intT)
        , T.Tuple "booleanT" (Domains.jsonCodec_BooleanT.encode p.booleanT)
        , T.Tuple "decimalT" (Domains.jsonCodec_DecimalT.encode p.decimalT)
        , T.Tuple "stringOptT" ((R.jsonCodec_maybe Domains.jsonCodec_StringT).encode p.stringOptT)
        , T.Tuple "intOptT" ((R.jsonCodec_maybe Domains.jsonCodec_IntT).encode p.intOptT)
        , T.Tuple "booleanOptT" ((R.jsonCodec_maybe Domains.jsonCodec_BooleanT).encode p.booleanOptT)
        , T.Tuple "decimalOptT" ((R.jsonCodec_maybe Domains.jsonCodec_DecimalT).encode p.decimalOptT)
        , T.Tuple "ref" ((jsonCodec_Ref jsonCodec_param_c).encode p.ref)
        , T.Tuple "refOpt" ((R.jsonCodec_maybe (jsonCodec_Ref jsonCodec_param_a)).encode p.refOpt)
        , T.Tuple "anotherRef" ((jsonCodec_Ref R.jsonCodec_int).encode p.anotherRef)
        , T.Tuple "yetAnotherRef" ((R.jsonCodec_maybe (jsonCodec_Ref R.jsonCodec_string)).encode p.yetAnotherRef)
        , T.Tuple "arrayOfB" ((R.jsonCodec_array jsonCodec_param_b).encode p.arrayOfB)
        , T.Tuple "aC" (jsonCodec_param_c.encode p.aC)
        , T.Tuple "xx" ((jsonCodec_MyList R.jsonCodec_string).encode p.xx)
        , T.Tuple "yy" ((jsonCodec_MyTuple R.jsonCodec_string R.jsonCodec_int).encode p.yy)
        ]
  }

type Ref a =
  { intTest :: Int
  , somethingA :: a
  }
type DecoderApi_Ref a =
  { nothing :: forall a. M.Maybe a
  , just :: forall a. a -> M.Maybe a
  , isLeft :: forall a b. E.Either a b -> Boolean
  , fromRight :: forall a b. Partial => E.Either a b -> b
  , right :: forall a b. b -> E.Either a b
  , left :: forall a b. a -> E.Either a b
  , addErrorPrefix :: forall a. String -> E.Either JsonDecodeError a -> E.Either JsonDecodeError a
  , jsonCodec_primitive_decimal :: R.JsonCodec Decimal
  , jsonCodec_somethingA :: R.JsonCodec a
  }
decoderApi_Ref :: forall a. R.JsonCodec a -> DecoderApi_Ref a
decoderApi_Ref jsonCodec_param_a =
  { nothing: M.Nothing
  , just: M.Just
  , isLeft: E.isLeft
  , fromRight: \(E.Right v) -> v
  , right: E.Right
  , left: E.Left
  , addErrorPrefix: \_ -> B.lmap identity
  , jsonCodec_primitive_decimal: R.jsonCodec_decimal
  , jsonCodec_somethingA: jsonCodec_param_a
  }
foreign import decode_Ref :: forall a. DecoderApi_Ref a -> A.Json -> E.Either JsonDecodeError (Ref a)
jsonCodec_Ref :: forall a. R.JsonCodec a -> R.JsonCodec (Ref a)
jsonCodec_Ref jsonCodec_param_a =
  { decode: decode_Ref (decoderApi_Ref jsonCodec_param_a)
  , encode: \p -> A.fromObject $
      FO.fromFoldable
        [ T.Tuple "intTest" (R.jsonCodec_int.encode p.intTest)
        , T.Tuple "somethingA" (jsonCodec_param_a.encode p.somethingA)
        ]
  }

type ArrayOfSomething a = Array a
jsonCodec_ArrayOfSomething :: forall a. R.JsonCodec a -> R.JsonCodec (ArrayOfSomething a)
jsonCodec_ArrayOfSomething jsonCodec_param_a =
  R.jsonCodec_array jsonCodec_param_a

type Foo = Array String
jsonCodec_Foo :: R.JsonCodec Foo
jsonCodec_Foo =
  R.jsonCodec_array R.jsonCodec_string

type RecordOfOther =
  { x :: Int
  , y :: Int
  }
type DecoderApi_RecordOfOther =
  R.StandardDecoderApi
decoderApi_RecordOfOther :: DecoderApi_RecordOfOther
decoderApi_RecordOfOther =
  R.standardDecoderApi
foreign import decode_RecordOfOther :: DecoderApi_RecordOfOther -> A.Json -> E.Either JsonDecodeError RecordOfOther
jsonCodec_RecordOfOther :: R.JsonCodec RecordOfOther
jsonCodec_RecordOfOther =
  { decode: decode_RecordOfOther (decoderApi_RecordOfOther)
  , encode: \p -> A.fromObject $
      FO.fromFoldable
        [ T.Tuple "x" (R.jsonCodec_int.encode p.x)
        , T.Tuple "y" (R.jsonCodec_int.encode p.y)
        ]
  }

data MyList a =
    Nil
  | Cons a (MyList a)
derive instance eqMyList :: Eq a => Eq (MyList a)
derive instance ordMyList :: Ord a => Ord (MyList a)
derive instance genericMyList :: Generic (MyList a) _
instance showMyList :: Show a => Show (MyList a) where
  show a = genericShow a
jsonCodec_MyList :: forall a. R.JsonCodec a -> R.JsonCodec (MyList a)
jsonCodec_MyList jsonCodec_param_a =
  R.composeCodec
    { decode: case _ of
        T.Tuple "Nil" [] -> E.Right Nil
        T.Tuple "Cons" [jsonParam_0, jsonParam_1] -> do
          param_0 <- jsonCodec_param_a.decode jsonParam_0
          param_1 <- (jsonCodec_MyList jsonCodec_param_a).decode jsonParam_1
          E.Right (Cons param_0 param_1)
        T.Tuple cn params -> E.Left $ TypeMismatch $ "Pattern match failed for " <> show cn <> " with " <> show (Array.length params) <> " parameters"
    , encode: case _ of
        Nil -> T.Tuple "Nil" []
        Cons param_0 param_1 -> T.Tuple "Cons" [jsonCodec_param_a.encode param_0, (jsonCodec_MyList jsonCodec_param_a).encode param_1]
    }
    R.jsonCodec_constructor

data MyTuple a b =
   MyTuple a b
derive instance eqMyTuple :: (Eq a, Eq b) => Eq (MyTuple a b)
derive instance ordMyTuple :: (Ord a, Ord b) => Ord (MyTuple a b)
derive instance genericMyTuple :: Generic (MyTuple a b) _
instance showMyTuple :: (Show a, Show b) => Show (MyTuple a b) where
  show a = genericShow a
jsonCodec_MyTuple :: forall a b. R.JsonCodec a -> R.JsonCodec b -> R.JsonCodec (MyTuple a b)
jsonCodec_MyTuple jsonCodec_param_a jsonCodec_param_b =
  R.composeCodec
    { decode: case _ of
        T.Tuple "MyTuple" [jsonParam_0, jsonParam_1] -> do
          param_0 <- jsonCodec_param_a.decode jsonParam_0
          param_1 <- jsonCodec_param_b.decode jsonParam_1
          E.Right (MyTuple param_0 param_1)
        T.Tuple cn params -> E.Left $ TypeMismatch $ "Pattern match failed for " <> show cn <> " with " <> show (Array.length params) <> " parameters"
    , encode: case _ of
        MyTuple param_0 param_1 -> T.Tuple "MyTuple" [jsonCodec_param_a.encode param_0, jsonCodec_param_b.encode param_1]
    }
    R.jsonCodec_constructor

data Blarg =
    Blue String
  | Green Int Int
  | Red
derive instance eqBlarg :: Eq Blarg
derive instance ordBlarg :: Ord Blarg
derive instance genericBlarg :: Generic Blarg _
instance showBlarg :: Show Blarg where
  show a = genericShow a
jsonCodec_Blarg :: R.JsonCodec Blarg
jsonCodec_Blarg =
  R.composeCodec
    { decode: case _ of
        T.Tuple "Blue" [jsonParam_0] -> do
          param_0 <- R.jsonCodec_string.decode jsonParam_0
          E.Right (Blue param_0)
        T.Tuple "Green" [jsonParam_0, jsonParam_1] -> do
          param_0 <- R.jsonCodec_int.decode jsonParam_0
          param_1 <- R.jsonCodec_int.decode jsonParam_1
          E.Right (Green param_0 param_1)
        T.Tuple "Red" [] -> E.Right Red
        T.Tuple cn params -> E.Left $ TypeMismatch $ "Pattern match failed for " <> show cn <> " with " <> show (Array.length params) <> " parameters"
    , encode: case _ of
        Blue param_0 -> T.Tuple "Blue" [R.jsonCodec_string.encode param_0]
        Green param_0 param_1 -> T.Tuple "Green" [R.jsonCodec_int.encode param_0, R.jsonCodec_int.encode param_1]
        Red -> T.Tuple "Red" []
    }
    R.jsonCodec_constructor

newtype X = X String
derive instance newtypeX :: Newtype X _
instance encodeJsonX :: EncodeJson X where
  encodeJson a = jsonCodec_X.encode a
instance decodeJsonX :: DecodeJson X where
  decodeJson a = jsonCodec_X.decode a
derive instance eqX :: Eq X
derive instance ordX :: Ord X
derive instance genericX :: Generic X _
instance showX :: Show X where
  show a = genericShow a
jsonCodec_X :: R.JsonCodec X
jsonCodec_X =
  R.codec_newtype R.jsonCodec_string
